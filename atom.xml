<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  <subtitle>欢迎来到1doctorc1的小破站</subtitle>
  <link href="https://1doctorc1.github.io/atom.xml" rel="self"/>
  
  <link href="https://1doctorc1.github.io/"/>
  <updated>2021-04-16T13:36:26.428Z</updated>
  <id>https://1doctorc1.github.io/</id>
  
  <author>
    <name>1doctorc1</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>电分查漏补缺</title>
    <link href="https://1doctorc1.github.io/2021/04/16/dian-fen-cha-lou-bu-que/"/>
    <id>https://1doctorc1.github.io/2021/04/16/dian-fen-cha-lou-bu-que/</id>
    <published>2021-04-16T13:36:02.000Z</published>
    <updated>2021-04-16T13:36:26.428Z</updated>
    
    <content type="html"><![CDATA[<p>电分考试</p><p>每次进行电路的等效时画出电路图</p><p>注意物理量的单位和运算基本法</p><p>注意标明换路定则，在哪个时间段内进行的分析</p><p>求等效电阻时，画出简化电路图以排除无关因素防止分析出错</p><p>不一定遇到的都是见过的体型，对解法的合理性进行分析，见到这样的题要先多思考</p><p>注意结题过程中公式的简化，消去，化简等</p><p>简单的题一定不要跳过太多底层逻辑，太容易错，加深对底层逻辑的理解</p><p>考虑解法，思路的整体性，完整性，完善性</p><p>求解值时，一定要列出公式，无论小题还是大题，大题就当拿过程分，小题防止计算出错</p><p>注意学习几种常见大题解法时的套话和分析流程完整性的学习</p><ol><li><p>由集总参数元件组成的电路称为集总参数电路</p><p>对电路使用集总参数假设进行分析的前提条件是：实际电路的几何尺寸远小于使用时其最高工作频率所对应的波长</p></li><li><p>关联参考方向：电流从电压的正极性端流向电压的负极性端</p></li><li><p>把每个二端元件看作一个支路，则每个支路的电压和电流都是未知量</p><p>对有n个节点、b条支路的电路，可以列n-1个独立的KCL方程，b-n+1个独立的KVL方程</p></li><li><p>两个单端口网络等效=端口电压、电流的关系完全相同</p></li></ol><ol><li><p>电压的符号：电分用U,u；但是模电必须用V,v;并且模电中iB(全值)=IB(直流量)+ib(交流量)</p></li><li><p>常用倍数关系，毫(-3),微(-6),纳(-9),皮(-12),m,u,n,p</p></li><li><p>第一章电路模型和电路元件目录：</p><ol><li>电路和电路模型</li><li>基尔霍夫定律</li><li>电阻及其等效变换，输入电阻</li><li>电压源，电流源，受控源</li><li>电源的等效变换</li></ol></li><li><p>节点，node</p></li><li><p>无源元件与有源元件</p><ol><li>不需要给元器件加电源就具有其特性的电流元器件，主要是电阻，电感，电容</li><li>主要是晶体三极管，集成电路</li></ol></li><li><p>受控源</p><ol><li>必须依托于控制量存在，若控制量消息则受控源也不存在(即受控电压源短路，受控电流源开路)</li><li>分析电路时，把受控源当作独立源，并带入控制量</li></ol></li><li><p>如果一个单口网络N和另一单口网络N’的端电压、电流关系相同，即伏安特性曲线相同，则称这两个单口网络是等效的</p><p>等效是相对于外电路而言的</p></li><li><p>输入电阻：端口电压和端口电流之比</p><p>端口网络中不能含有独立电流源，可以含有受控源，这时单口网络可以等效为一个电阻，等效电阻值可能为负值</p></li><li><p>两种电流源模型可以等效变换，对负载提供相同的功率，但电源内部不等效</p></li><li><p>理想电压源不能短路，短路电流无穷大；理想电流源不能断路，断路电压无穷大</p></li></ol><ol><li><p>支路电流法：</p><ol><li>按网孔列出的回路电压方程是独立的，也就是网孔数等于独立的KVL方程数</li></ol></li><li><p>节点电压法</p><ol><li>基础概念<ol><li>参考节点：在电路中任意选定的电位为0的节点</li><li>节点电压：其他节点与参考节点之间的电位差，通常取参考节点为节点电压’-‘端</li><li>互电导，当电路中没有受控源时，Gij=Gji</li></ol></li><li>几种特殊情况<ol><li>若支路为电压源和电阻串联，则可以等效为电流源和电阻并联</li><li>电路中含有理想电压源<ol><li>如果理想电压源在参考节点与非参考节点之间，则该节点电压已知</li><li>如果在非参考节点与非参考节点之间，可设电压源所在支路电流为未知量，并且增加一个电压源支路的节点电压方程</li><li>电路中有几个电压源支路就增加几个方程</li><li>列方程时，如果题目中没有指定参考节点，则应尽可能地选定电压源的一个节点为参考节点</li></ol></li><li>如果电路含有理想电流源和电阻并联的支路，这列节点电压方程时不考虑该电阻</li><li>当电路中含有受控源支路时，把受控源按独立源对待，并把<u>控制量</u>用节点电压表示，即增加一个控制量与节点电压的关系方程</li></ol></li></ol></li></ol><ol><li><p>第三章电路的基本定理目录：</p><ol><li>齐性定理：只含一个激励源</li><li>叠加定理：多个激励源单独作用的叠加</li><li>替代定理：用激励源去替代已知支路</li><li>戴维南定理和诺顿定理</li><li>最大功率传输定理</li></ol></li><li><p>叠加定理：在有电阻，独立源，受控源组成的线性电路中，元件的<strong>电流，电压</strong>可以看成是由每个独立源单独作用时，在该元件上产生的电流或电压的代数和</p><p>受控源不能单独作用，即独立源单独作用时，受控源必须保留在电路中，而且要注意控制量的变化</p><p>功率不能叠加</p><p><u>应用叠加定理解题时，当单个独立源单独作用时，说明白如何将其他独立源置零，电压源短路，电流源开路</u></p></li><li><p>叠加定理的注意事项</p><ol><li>叠加定理只能用于线性电路</li><li>叠加时要注意电压电流的方向</li><li>功率不能用于叠加定理</li><li>应用叠加定理时，<strong>受控源要保留</strong></li></ol></li><li><p>戴维南定理和诺顿定理</p><ol><li>任何含源线性单口网络N(含有电源，线性元件，受控源),就端口特性而言，都可以将该单口网络等效为一个电压源和一个电流源的串联</li><li>电压源的电压等于网络N的开路电压Uoc，等效电阻的阻值等于该网络除源(<strong>独立源为零值，但是受控源保留</strong>)，所得网络N0的等效电阻</li><li>用叠加定理证明戴维南等效电路：<ol><li>N中独立源单独作用：u’=uoc</li><li>外接电流源作用于除源端口网络：u’’=i*Req</li><li>VCR法：u=u’+u’’=uoc-i*Req</li></ol></li><li>韩受控源的等效电阻阻值可能为负值</li></ol></li><li><p>最大功率传输定理：由含源线性单口网络传递给可变负载RL的功率的最大的条件是RL=Rs</p></li></ol><ol><li><p>电容元件的VCR:i=C*(du/dt)，注意这是在关联参考方向下，即电流从电容的正极流向电容的负极</p></li><li><p>注意电容和电感的VCR关系！！！</p></li><li><p>电容只有微法和皮法两个向下的单位，进位是10^(-6)</p></li><li><p>电容元件储存的能量：Wc(t)=1/2*Cuc(t)^2</p></li><li><p>电感元件的VCR:u=L*(di/dt)</p></li><li><p>一阶RC，RL电路的零输入响应是一个放电的过程</p></li><li><p>RC电路：tao=RC</p></li><li><p>RL电路：tao=L/R</p></li><li><p>工程上常取t=(4-5)tao,作为放电完毕所需的时间</p></li><li><p>电压，电流衰减的快慢取决于时间常数的大小，tao越大，衰减越慢，反之则越快</p></li><li><p>时间常数</p><ol><li>同一电路中各响应量的时间常数相同，零输入响应和全响应都有这样的特点</li><li>求解电路中的电压、电流只涉及根据KCL、KVL进行的加减运算，根据元件的VCR进行的乘除，积分微分运算，这些运算都不会改变指数函数的形式</li></ol></li><li><p>零状态响应：电路的储能元件初始储能为零，仅有外部激励作用而产生的响应</p></li></ol><p>正弦稳态电路：</p><ol><li>幅值下标带m，角频率w=2* pi *f，注意题中给的是频率还是角频率</li><li>初相大于零：最大值发生在原点之左；初相小于零：最大值发生在原点之右</li><li>周期信号的平均值计算方式：对周期信号在一个周期内对t积分平均上周期</li><li>周期信号的有效值的求法：等于瞬时值平方在一个周期内的平均值的平方根</li><li>大多数交流电压表和交流电流表也都是测量有效值的，数据一般都是交流电压、电流的有效值</li><li>相量图：x轴+1，y轴+j</li><li>基尔霍夫定律的相量形式，相加的是相量的代数和，而不是有效值的代数和</li><li>电阻元件的电流和电压同相，电感的两端电压超前流过电感的电流90°，流过电容的电流的相位超前电容两端的电压90°</li><li>欧姆定理的相量形式，阻抗的单位和电阻相同</li><li>电感和电容的阻抗均为虚数，用符号X表示他们的大小，电感的电抗XL=WL，电容的电抗XC=-1/WC</li><li>单个元件的阻抗和导纳互为倒数</li><li>Z=R+jX，Z即为单口网络的阻抗，X=WL-1/WC即为单口网络的电抗</li><li>相关的物理量，阻抗的模等于电压的有效值与电流的有效值之比，阻抗角等于电压和电流相位差</li><li>对于无源端口网络，其阻抗和导纳互为倒数</li><li>正弦稳态电路的等效：根据戴维南定理，含源的正弦稳态电路可以用阻抗与电压源串联或阻抗与电流源并联的形式等效。对于不含独立源的单口网络(无源单端口网络),则可以直接用阻抗等效，此即无源单口网络的等效阻抗，也即输入阻抗</li><li>正弦稳态最大功率传输定理：当负载为纯电阻时，不可能实现共轭匹配使负载获得最大功率，按照模匹配考虑，RL=内阻抗的模；同理，如果电源内阻为纯电阻，则不管负载阻抗形式如何，也按照模匹配形式考虑最大功率传输定理</li></ol><p>功率因数角：端口电压与电流的相位差，对于无源单口网络，也是等效阻抗的阻抗角</p><p>在电流电压的单位是安培和伏特时，无功功率的单位是乏var</p><p>视在功率的定义：端口电压和端口电流有效值的乘积，视在功率的单位是伏安(VA)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;电分考试&lt;/p&gt;
&lt;p&gt;每次进行电路的等效时画出电路图&lt;/p&gt;
&lt;p&gt;注意物理量的单位和运算基本法&lt;/p&gt;
&lt;p&gt;注意标明换路定则，在哪个时间段内进行的分析&lt;/p&gt;
&lt;p&gt;求等效电阻时，画出简化电路图以排除无关因素防止分析出错&lt;/p&gt;
&lt;p&gt;不一定遇到的都是见过的体型，对解</summary>
      
    
    
    
    
    <category term="模电" scheme="https://1doctorc1.github.io/tags/%E6%A8%A1%E7%94%B5/"/>
    
  </entry>
  
  <entry>
    <title>电分</title>
    <link href="https://1doctorc1.github.io/2021/04/16/dian-fen/"/>
    <id>https://1doctorc1.github.io/2021/04/16/dian-fen/</id>
    <published>2021-04-16T13:32:48.000Z</published>
    <updated>2021-04-16T14:03:03.722Z</updated>
    
    <content type="html"><![CDATA[<p>电分</p><p><img src="C:\Users\张驰\AppData\Roaming\Typora\typora-user-images\image-20210331191614846.png" alt="image-20210331191614846"></p><h2 id="电路模型和电路元件"><a href="#电路模型和电路元件" class="headerlink" title="电路模型和电路元件"></a>电路模型和电路元件</h2><h3 id="电路基本变量"><a href="#电路基本变量" class="headerlink" title="电路基本变量"></a>电路基本变量</h3><p>电压源(Us),电流源(Is)</p><p>分析时，通常将电压和电源的参考方向选为一致，即电流从电压正极性端流向电压负极性端，这被称为关联参考方向</p><p><code>p=u*i</code>，为电压和电流为关联参考方向下的计算式，<code>p=-u*i</code>为电压和电流为非关联参考方向下的计算式</p><h3 id="KCL和KVL"><a href="#KCL和KVL" class="headerlink" title="KCL和KVL"></a>KCL和KVL</h3><p>支路：连接于电路中的每个二端元件就定义为一条支路</p><p>支路电流：流过该支路的电流(一条支路上电流处处相等)，反之一条电路中电流处处相等不一定为一条支路</p><p>支路电压：该支路两端的电压</p><p>结点：电路中支路的连接点</p><p>支路数和节点数会影响电路的方程数</p><p>KCL不仅应用于节点，也可以推广应用到一个闭合面(也成为广义节点)</p><p>KVL的表述：回路中各支路电压的代数和为0</p><p>列些KVL方程之前，要先规定好回路的绕行方向，如果支路电压的参考方向和绕行方向一致为正，反之，为负</p><p>KVL也可用于闭合的节点序列</p><blockquote><p>KVL用于求闭合节点序列，特别是端口电压时，可以将端口电压按方向等效为电压源，从负极到正极为电压增加</p></blockquote><p>VCR，线性电阻元件电压电流关系，R的计算，也受电压和电源关联参考方向的影响</p><p>无源元件：，有源元件：</p><p>无源元件和有源元件的差别详看电分查漏补缺</p><h3 id="电压源和电流源"><a href="#电压源和电流源" class="headerlink" title="电压源和电流源"></a>电压源和电流源</h3><p>理想电压源的特性：端电压固定或为时间的函数，流过其电流仅有与其相连的外电路决定</p><p>理想电流源的特性：供出的电流固定或为时间的函数，<strong>电流源两端</strong>的电压由与之相连的外电路决定</p><p>受控源的功率为：<code>p=u1*i1+u2*i2</code>,但是控制电路不是开路就是短路，所以恒有<code>u1*i1=0</code>,因此受控源的功率就是受控电路的功率，即：<code>p=u2*i2</code></p><p>线性电路：由非时变线性元件，线性受控源，独立源组成的非时变线性电路</p><p>等效电阻通常用Req表示</p><p><strong>电阻的等效替换可能没有明显的串联和并联，可以根据简单串并联的特点，去推测复杂情况下电阻是否为串并联，串：流过的电流为同一电流，并：两端的电压为同一电压</strong></p><p>电压源的等效：多个电压源串并联的等效</p><p>特殊的：根据电压源的特性，只有电压值相同且电极性一致的电压源才可以并联，而且对外电路来说其和一个电压源等效，任何元件和电压源并联都等效于电压源</p><p>电流源的等效：多个电流源串并联的等效</p><p>特殊的：根据电流源的特性，只有电流值相同且电极性一致的电流源才可以串联，而且对外电路来说其和一个电流源等效，任何元件和电流源串联都等效于电流源</p><p>电压源和电流源的等效替换，电压源变为电流源，<strong>电流方向为从负极性端流向正极性端</strong></p><p><strong>对含有受控源的电路进行等效替换时，不能化简将控制量化去，在含有受控源的电路中，一定要保留控制量</strong></p><p>输入电阻的对象：单口网络(不含有独立电源，可以含有受控源)，定义端口电压和电流之比为该单口网络的输入电阻</p><p>如果电流从＋极流出则Req=u/i</p><p>如果电流流入＋极则Req=-u/i</p><p>1-6：是电流源所在支路，支路电流一致，还是前后不一致，比如入是-2A，电流源参数是-2A，还是可以为其他数，并且出的电流和-2A叠加？  答案是前者，这么说电流源是个测电流的？还是我对电路中的电流理解有问题？</p><h2 id="电阻电路的基本分析方法"><a href="#电阻电路的基本分析方法" class="headerlink" title="电阻电路的基本分析方法"></a>电阻电路的基本分析方法</h2><h3 id="支路电流法"><a href="#支路电流法" class="headerlink" title="支路电流法"></a>支路电流法</h3><p>KCL和KVL独立方程数：对于含有n个节点，b个支路的电路网络，每一个支路都有其支路电流和支路电压，所以总共有<strong>2b个变量</strong>，<strong>n个节点可以用KCL列出n-1个独立的电流方程</strong>，<strong>再列出和网孔数量相同b-n+1的KVL方程</strong>，再加上每个支路各自的VCR方程求解任意未知变量</p><p><strong>续上，此电路中有b-n+1个独立完备的电流变量，n-1个独立的电压变量</strong></p><p>支路电流法解题过程：列出KCL方程，列出KVL方程，列出VCR方程(用电流表示电压)，将VCR方程代入KVL方程和KCL方程联立求解（可以在列KVL方程时直接代入VCR方程）</p><p>在使用支路电流法时，如果出现已知电流大小的电流源，则电流源所在支路的电流是已知的，但是将会带来电流源两端的电压这个未知变量</p><p>根据所求未知变量的不同，可类似用支路电压法</p><h3 id="节点电压法"><a href="#节点电压法" class="headerlink" title="节点电压法"></a>节点电压法</h3><p><img src="C:\Users\张驰\AppData\Roaming\Typora\typora-user-images\image-20210416220259683.png" alt="image-20210416220259683"></p><p>节点电压法是以节点电压为电路变量列写方程进行求解的一种分析方法</p><p>节点电压法：选定参考节点，剩下的节点为独立节点，独立节点和参考节点之间的电压成为<strong>节点电压</strong>，对独立节点(正好数量为n-1)列出KCL，<strong>用节点电压表示支路电压</strong>，将其带入到VCR中，最后带入到KCL方程中求解，最后整理得到的是各节点的<strong>以节点电压为变量的方程</strong>。</p><p>综合运用了KCL定律和欧姆定律</p><p>对于只含独立源和电阻的电路，节点电压方程可以直观的列些出来</p><p>节点电压法矩阵形式各部分意义：<br>自电导：对角线上的元素代表和相应位置节点直接相连的支路的电导之和</p><p>互电导：非对角线上的元素则根据在矩阵中的下标表示相邻两节点之间支路电导的负值，<strong>若两节点间无公共支路，互电导为0</strong>，对于只含独立源和电阻的电路，<code>Gij=Gji</code></p><p>结果矩阵中的元素则是与节点直接相连的支路有无独立电流源，<strong>流入节点为正，流出节点为负</strong>，注意是独立电流源而不是支路中的电流都可以</p><p>对电压源来说，如果有与电压源串联的电路，则可以先把电压源和串联的电路变换为电流源与电阻并联的形式，当然，如果电压源的正极性端和节点相连，表示转换后的电流源的电流是流入节点的，为正，反之为负</p><p>通常，除电压源与电阻串联的支路和电流源与电阻并联的支路可以看作一条支路外，其余元件均以一个元件作为一条支路</p><p>理想电压源支路(即电压源不和电阻串联无法转换为电流源和电阻并联)分两种情况考虑，一种是电压源接在独立节点和参考节点之间，则此时支路电压已知，即为电压源电压，另一种情况是电压源接在独立节点和独立节点之间，此时引入该支路电流这个未知变量，因此需要增加方程个数才能求解，该方程为电压源支路电压与相关节点电压的关系方程(<strong>或者将该支路电流当作电流源来处理</strong>，<strong>仍需添加支路电压与节点电压方程</strong>)</p><p>列写方程时，如果电路中未事先指定参考节点，则应尽可能将连接理想电压源支路的节点选为参考节点</p><p>在列些节点电压方程时，不考虑与电流源串联的电阻</p><p><strong>当电路中含有受控源时，首先把受控源当作独立源对待</strong>，然后把控制量用节点电压表示，即增加一个控制量就增加一个控制量与节点电压方程，电路中有几个受控源，就要增加几个方程。</p><p>如果电路中有受控电压源与电阻串联或者理想受控电压源支路，则可以用对待独立电压源同样的处理方式对待</p><p>当电路中含有受控源时，互电导不再相同</p><p>如果没有与电压源串联的电阻则是一种特殊情况</p><p><strong>注意事项：</strong></p><ul><li>求自电导注意和电压源串联的电阻</li><li><strong>如果已知某一非参考节点与参考节点之间有已知电压源，则该节点的一般节点电压方程不用列，直接补充增列方程</strong></li><li>不是每个和节点相连的电路元件的电导，而是每个和节点相连的支路的总电导</li><li>做题时直接通过观察写出自电导，互电导，电流，然后写出通用表达式代入得方程组，联立其他方程组求解</li><li>电路中有几个受控源就增加几个方程</li><li>节点可以合并，列方程时不存在两个节点直接两连，而中间没有任何元件的情况<u>（2.12）</u></li></ul><h2 id="电路的基本定理"><a href="#电路的基本定理" class="headerlink" title="电路的基本定理"></a>电路的基本定理</h2><h3 id="齐性定理"><a href="#齐性定理" class="headerlink" title="齐性定理"></a>齐性定理</h3><p>齐性定理：在<strong>单一激励的线性电路</strong>中，如果激励增加或减小K倍，则响应也同时增加或减小K倍</p><p>常用于梯形电路，使用倒推法，即先假设待求量为一个容易计算的值，由此向前推算出对应待求量的输入值，从而找出输入和输出(待求量)的比例关系，根据齐次定理，再求对应此输入的输出值</p><h3 id="叠加定理"><a href="#叠加定理" class="headerlink" title="叠加定理"></a>叠加定理</h3><p>叠加定理是当电路中有多个激励的线性电路的齐次定理的考虑</p><p>叠加定理：在有线性电阻，线性受控源和独立电源组成的电路中，每一个元件的电流和电压都可以视为每一个独立源单独作用产生的电流和电压的代数和</p><p>单独作用的含义是：当某一独立源单独作用时，其他独立源应为零值，即独立电压源(所供电压为0)短路，独立电流源(所供电流为0)断路</p><p>注意：</p><ul><li>根据受控源的性质，受控源是不能单独作用的，所以，独立源单独作用时，受控源必须保留在电路中，而且要注意控制量的变</li><li>进行叠加时，还要注意电压、电流的所设参考方向，总电压、电流是各独立源单独做用时产生的分电压、电流的代数和。分电压、电流的参考方向与总电压、电流的参考方向相同时取正，相反时取负。</li></ul><p>叠加定理叠加的是电压和电流，无法叠加功率<code>p=(u&#39;+u&#39;&#39;)(i&#39;+i&#39;&#39;)=u&#39;i&#39;+u&#39;i&#39;&#39;+u&#39;&#39;i&#39;+u&#39;&#39;i&#39;&#39;     !=u&#39;i&#39;+u&#39;&#39;i&#39;&#39;</code></p><h3 id="替代定理"><a href="#替代定理" class="headerlink" title="替代定理"></a>替代定理</h3><p>替代定理：若某网络中所有的支路电压和支路电流都有唯一解，且已知某支路k的电流为Ik，电压为Uk，则可以用电压为Uk的电压源或者电流为Ik的电流源等效替代这条支路，替换后其他部分的电流值和电压值不变</p><p>这里所说的一条支路可以是单一元件构成的支路，也可以是几个元件构成的复合支路，或者说是网络中的一部分</p><p>这个定理同样解释了任何元件和电流源串联仍等效为一个电流源，任何元件和电压源并联仍等效为一个电压源</p><p>替代定理不仅适用于线性电路，也适用于非线性电路</p><p>注意：</p><ul><li><p>替换后，只能用于求解其他各部分的电流和电压，不能进行电阻的等效替换，因为此时电路已经发生改变</p></li><li><p><strong>如果某支路有控制量，则不能使用等效替换替换掉受控源或者控制源，至少像叠加定理一样保留至少一个控制源</strong></p></li></ul><h3 id="戴维南定理和诺顿定理"><a href="#戴维南定理和诺顿定理" class="headerlink" title="戴维南定理和诺顿定理"></a>戴维南定理和诺顿定理</h3><p>一个复杂的网络可以用一个独立电压源和一个电阻串联的电路替代，这就是戴维南定理</p><p>一个复杂的网络可以用一个独立电流源和一个电阻并联的电路替代，这是诺顿定理</p><p>任何<strong>含源</strong>线性单口网络N(指含有独立源、线性电阻及线性受控源的单口网络)，不论其结构如何复杂，就其端口特性而言，都可以用一个电压源与一个电阻的串联支路等效替代。</p><p><strong>其中，等效电压源的电压等于网络N的开路电压Uoc，串联电阻Req等于网络N除源(即所有独立源均为零值，但受控源要保留)后，所得网络N0的等效电阻</strong></p><p>戴维南定理的证明：端口电压<code>v=v&#39;(voc)+v&#39;&#39;(-Reqi)</code></p><p>即端口电压等于端口开路，i=0时的开路电压加去源后</p><p>如何理解去源呢？即端口电压为N网络和外接电流源的叠加，是叠加定理的应用</p><p>对于不含受控源的单口网络，其等效电阻也容易利用电阻串、并联及星形-三角形变换求出，难点在于含受控源网络的等效电阻的求解</p><p><strong><u>对于含有受控源的单口网络，通常采用两种方法求其等效电阻：外加电流法和短路电流法</u></strong></p><ol><li><p>外加电源法求等效电阻</p><p>基于单口网络的输入电阻的概念而来的，在<strong>除源后</strong>的单口网络N0的端钮外加一个电压源U0或一个电流源I0，求端口处的电流I0或电压U0，则端口电压和端口电流的之比即为该单口网络的等效电阻。</p><p>注意：</p><ul><li>如果i0从单端口网络的正极性端流向负极性端，即I0是和单端口网络为关联参考方向，则Req=U0/I0，但是此时，U0和I0不是关联参考方向</li></ul></li><li><p>短路电流法求等效电阻</p><p>基于单口网络的伏安特性而来，当端口开路时，u=uoc，当端口短路时，i=isc=uoc/Req，即含源单口网络的戴维南等效电阻等于该单口网络的端口电压Uoc与短路电流Isc之比。</p><p>注意：</p><ul><li>Uoc、Isc均由含源的单口网络求得，且应用该式时要注意开路电压和短路电流的方向</li><li>如果单口网络中不含独立源而只含受控源，则不能用此方法，应该用外加电源法</li></ul></li><li><p>戴维南等效电路的VCR确定法</p><p>u=Uoc-IReq</p></li></ol><p>做题时的问题：</p><ul><li>求戴维南等效电压时，开路口必定电流为0，受控电压源对这一开路支路电流没有影响，但受控电压源很有可能会影响开路电压</li><li>在闭合节点序列用KVL注意假设外接电压源时电压的方向</li><li>单口网络N中不能含有控制量在外部电路的受控源，但控制量可以是N的端口的电压或电流。即在进行网络分解时，一定要把受控源及其控制量放在同一部分</li><li>VCR关系和外加电源法同样是在端口加u和i（外加电源是U0和I0)，为啥得到的结果不一样呢？因为一个是考虑到了内部的电源，相当于把没等效前的所有电路都考虑进去（<strong>类比于戴维南定理证明叠加后的电路</strong>），而外加电源法是没考虑内部的电源，相当于戴维南定理证明时的只考虑外部的那部分电路</li></ul><h2 id="一阶动态电路"><a href="#一阶动态电路" class="headerlink" title="一阶动态电路"></a>一阶动态电路</h2><p><img src="C:\Users\张驰\AppData\Roaming\Typora\typora-user-images\image-20210416215756253.png" alt="image-20210416215756253"></p><h3 id="电容"><a href="#电容" class="headerlink" title="电容"></a>电容</h3><p>电容元件的电荷电压关系q=Cu</p><p>i=dq/dt，如果是串联的电容，则流过他们的电流相同，q为定值，即电容两端的电压与其电容成反比</p><p>电容元件的电流于其两端的电压具有微分关系</p><p>某时刻的电流值不是取决于该时刻的电压值，而是由该时刻电压的变化率决定的</p><p>在电容电流为有界值的情况下，电容电压不能跃变</p><p>某时刻电容的储能只与该时刻的电容电压有关，且储能总为正，电容元件为无源元件，但是其储能有时会增加，有时会减少，对应储存能量和释放能量</p><p>等效电容的倒数是各串联电容倒数之和</p><p>等效电容是各并联电容之和</p><h3 id="电感"><a href="#电感" class="headerlink" title="电感"></a>电感</h3><p>电感元件两端的电压与通过它的电流具有微分关系</p><p>某时刻的电压值不是取决于该时刻的电流值，而是由该时刻电流的变化率决定</p><p>在电感电压为有界值的情况下，电感电流不能跃变</p><p>某时刻电感的储能只与该时刻的电感电流有关，且储能总为正，因此电感元件是无源元件</p><p>等效电感的倒数是各并联电感的倒数之和</p><p>等效电感是各串联电容之和</p><h3 id="换路定则及其初始值的确定"><a href="#换路定则及其初始值的确定" class="headerlink" title="换路定则及其初始值的确定"></a>换路定则及其初始值的确定</h3><p>换路定则：在电容电流和电感电压为有界值的情况下，电容电压不能跃变，电感电流不能跃变，将这一性质为换路定则</p><p>Uc(0+)、il(0+)是电路已处于稳定状态，且在换路前一瞬间的电容电压和电感电路</p><p>因为在直流激励下，电容相当于开路，电感相当于短路，由此可以得到0-时刻的等效电路，并据此计算初始状态</p><p>0+时刻的等效电路是在0+时刻将电路中的电容用电压值等于Uc(0+)的电压源代替，将电感用电流值等于iL(0+)的电流源代替，独立源则取其在0+时的值得到的电路</p><p>做题注意：</p><ul><li><p>求diL/dt只能是对于电感元件，用UL/L得到</p></li><li><p>同理dUc/dt</p></li><li><p>那么怎么求一般元件的du/dt或者di/dt呢？</p></li></ul><h3 id="一阶电路的零输入响应"><a href="#一阶电路的零输入响应" class="headerlink" title="一阶电路的零输入响应"></a>一阶电路的零输入响应</h3><p>如果已知电容电压和电感电流在初始时刻的值，则根据该时刻的输入就能确定电路中的任何变量在随后时刻的值，将具有这种特性的量，即电容电压和电感电流称为状态变量</p><p>在动态电路中，通常都以状态变量作为未知量来列些方程</p><p>一阶RC电路的零输入响应：y(t)=y(0+)e(-t/tao)，其中tao为RC</p><p>一阶RL电路的零输入响应：上式tao为L/R</p><p>时间常数影响过渡过程的快慢，时间常数越小，过渡过程越快</p><p>同一电路中各相应量的时间常数相同</p><h3 id="一阶电路的零状态响应"><a href="#一阶电路的零状态响应" class="headerlink" title="一阶电路的零状态响应"></a>一阶电路的零状态响应</h3><p>y(t)=y(∞)(1-e(-t/tao))</p><p>对于任何一阶RC和RL电路来说，电容电压和电感电流的零状态响应都具有上式的形式</p><p>只要求得电容电压和电感电流在t-&gt;∞时的值，称其为稳态值，以及电路的时间常数，就可以得到电容电压和电感电流的变化规律</p><p>需要注意的是，该式只适用于电路的状态变量，对其他量不适用</p><p>所谓零状态是指状态变量的初始储能为零，从而初始值也为零，即y(0+)=0，零状态响应的公式是状态变量从零值逐渐达到稳态值y(∞)的过渡过程，对于非状态变量，由于其不满足换路定则，所以，虽然状态变量初始值为0，但非状态变量的初始值不一定为零，在y(0+)！=0的情况下，就不满足上式</p><p>当电路比较复杂时，通常也利用戴维南定理或诺顿定理将除动态元件以外的电路用戴维南等效电路或诺顿等效电路替代，所以，公式tao=RC和tao=L/R中的R即为与动态元件连接的戴维南等效电阻或诺顿等效电阻</p><h3 id="一阶电路的全响应"><a href="#一阶电路的全响应" class="headerlink" title="一阶电路的全响应"></a>一阶电路的全响应</h3><p>稳态响应是电路达到新的稳定状态时的电容电压值或电感电流值</p><p>暂态响应：具有指数形式，随着时间增加，它会逐渐趋近于0</p><p>全响应可以看作零输入响应与零状态响应的叠加，也可以看作稳态响应与暂态响应的叠加</p><h3 id="一阶电路的三要素法"><a href="#一阶电路的三要素法" class="headerlink" title="一阶电路的三要素法"></a>一阶电路的三要素法</h3><p>求解RC电路各元件量的方法分为两个：零输入响应和零状态响应的叠加        和        稳态响应与暂态响应的叠加</p><p>三要素法就是指后者</p><p>只需知道待求量的初始值、稳定值、电路的时间常数3个量就能得到该量的解</p><p>既适用于状态变量，也适用于非状态变量，即在直流激励下，一阶动态电路中任一支路的电流、电压都可以利用三要素法求解</p><h3 id="时间常数tao"><a href="#时间常数tao" class="headerlink" title="时间常数tao"></a>时间常数tao</h3><p>电路处于暂态过程中，当t=(4~5)tao就可以将电路视作稳态</p><h2 id="正弦稳态电路"><a href="#正弦稳态电路" class="headerlink" title="正弦稳态电路"></a>正弦稳态电路</h2><p>输入电子设备的信号通常是交变信号，利用傅里叶级数展开可将此交变信号展开为一系列不同频率的正弦波</p><h3 id="正弦量的相量表示"><a href="#正弦量的相量表示" class="headerlink" title="正弦量的相量表示"></a>正弦量的相量表示</h3><p>正弦量的三要素：</p><ol><li>Fm：正弦量的最大值，幅值</li><li>w：正弦量的角频率，相位随时间变化的快慢</li><li>fai：初相</li></ol><p>同频率正弦量的代数和、微分、积分结果仍为同频率的正弦量</p><p>由于周期信号的平均值通常为0，所以引入有效值</p><h3 id="基尔霍夫定律的相量形式"><a href="#基尔霍夫定律的相量形式" class="headerlink" title="基尔霍夫定律的相量形式"></a>基尔霍夫定律的相量形式</h3><h3 id="RLC元件VCR的相量形式"><a href="#RLC元件VCR的相量形式" class="headerlink" title="RLC元件VCR的相量形式"></a>RLC元件VCR的相量形式</h3><h3 id="正弦稳态电路的相量分析"><a href="#正弦稳态电路的相量分析" class="headerlink" title="正弦稳态电路的相量分析"></a>正弦稳态电路的相量分析</h3><h3 id="正弦稳态电路的等效"><a href="#正弦稳态电路的等效" class="headerlink" title="正弦稳态电路的等效"></a>正弦稳态电路的等效</h3><h3 id="正弦稳态电路的功率"><a href="#正弦稳态电路的功率" class="headerlink" title="正弦稳态电路的功率"></a>正弦稳态电路的功率</h3><p>单口网络的平均功率，P=U*Icos(fai)</p><p>其中这个U，I分别是端口电压和端口电流的有效值</p><p>平均功率就是瞬时功率的恒定分量，平均功率表示单口网络实际消耗或产生的功率，所以又称为有功功率</p><p>注意：</p><ul><li>U，I并不是正弦等效电路中电阻部分两端的U，I</li></ul><p>单口网络的无功功率，P=U*Isin(fai)</p><p>为了衡量网络与外加电源间能量交换的规模，就是无功功率</p><p>单口网络的视在功率，S=U*I</p><p>总结：</p><ul><li>纯电感或电容的额有功功率为零，电感元件和电容元件不消耗能量</li><li>电阻的瞬时功率就是网络消耗的功率</li></ul><p>单口网络功率的其他计算方法</p><p><strong>无源单口网络的有功功率其实就是网络中所有电阻元件消耗的功率之和，也等于端口所接电源提供的有功功率</strong></p><p>视在功率不满足功率守恒定则</p><h2 id="耦合电感电路"><a href="#耦合电感电路" class="headerlink" title="耦合电感电路"></a>耦合电感电路</h2><h3 id="互感，互感电压"><a href="#互感，互感电压" class="headerlink" title="互感，互感电压"></a>互感，互感电压</h3><p>在两个线圈之间有耦合的情况下，每个线圈中的电压有两部分组成：一部分为本身电流的产生的自感电压，一部分为耦合线圈中电流产生的互感电压</p><p>同名端的判断：</p><p>如果一个线圈中电流从同名端流入，则另一个线圈的同名端就是在该线圈中产生的互感电压的正极性端</p><h3 id="耦合电感的电压、电流关系"><a href="#耦合电感的电压、电流关系" class="headerlink" title="耦合电感的电压、电流关系"></a>耦合电感的电压、电流关系</h3><p><strong>互感电压可以用一受控源表示</strong></p><p><strong>等效后的模型中电感之间不再耦合，成为一般的电感元件</strong></p><p>总结：</p><ul><li>在<strong>具有耦合的电感线圈上</strong>存在着两种电压，即自感电压和互感电压</li></ul><h3 id="理想变压器的VCR及其特性"><a href="#理想变压器的VCR及其特性" class="headerlink" title="理想变压器的VCR及其特性"></a>理想变压器的VCR及其特性</h3><p>理想变压器：初级和次级线圈的自感系数和两线圈之间的互感系数均趋于无穷大，但是两个线圈自感系数的比值为一常数，且等于两个线圈的匝数比</p><p>L1=n*L2</p><p>电压，电流关系(相量式)</p><p>U1=n*U2</p><p>I1=-1/n*I2</p><p>即：初级电压和次级电压之比等于其匝数之比</p><p>初级电流与次级电流等于其匝数比的倒数</p><p>其方向和正负关系：</p><p>如果u1，u2的参考方向与同名端相同，则电压关系式前取正号，反之，取负号</p><p>如果i1，i2均从同名端流入，则电流关系式前取负号，反之，取正号</p><p>理想变压器的阻抗变换性质</p><p>称n^2 ZL为副边阻抗ZL对原边的折合阻抗</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;电分&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;C:\Users\张驰\AppData\Roaming\Typora\typora-user-images\image-20210331191614846.png&quot; alt=&quot;image-20210331191614846&quot;&gt;&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="模电" scheme="https://1doctorc1.github.io/tags/%E6%A8%A1%E7%94%B5/"/>
    
  </entry>
  
  <entry>
    <title>openmv机器视觉</title>
    <link href="https://1doctorc1.github.io/2021/03/04/openmv-ji-qi-shi-jue/"/>
    <id>https://1doctorc1.github.io/2021/03/04/openmv-ji-qi-shi-jue/</id>
    <published>2021-03-04T09:53:42.000Z</published>
    <updated>2021-03-04T09:54:03.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="openmv机器视觉"><a href="#openmv机器视觉" class="headerlink" title="openmv机器视觉"></a>openmv机器视觉</h1><h3 id="摄像头应用"><a href="#摄像头应用" class="headerlink" title="摄像头应用"></a>摄像头应用</h3><p>”文件“—-“示例”—-“Basics”—-“helloworld”</p><p>理解OpenMV4摄像头基本编程和配置原理</p><p>OpenMV将摄像头功能封装到Sensor模块中</p><p>sensor模块：</p><ul><li>构造函数 sensor  摄像头对象，通过import直接调用</li><li>使用方法：<ul><li>sensor.reset()  初始化摄像头   <u>清除掉之前摄像头存在的代码对于图片的设置</u></li><li>sensor.set_pixformat(pixformat)<ul><li>设置像素格式，pixformat有3个参数</li><li>sensor.GRAYSCALE:灰度图像，每像素一个字节</li><li>sensor.RGB565:每像素为16位，5位用于红色，6位用于绿色，5位用于蓝色</li><li>sensor.BAYER:占空间小，仅捕捉图像用，不可做图像处理</li></ul></li><li>sensor.set_framesize(framesize)<ul><li>设置每帧大小(即图像尺寸)，常用的framesize参数：</li><li>sensor.QQVGA:160*120</li><li>sensor.QVGA:320*240</li><li>sensor.VGA:640*480</li></ul></li><li>sensor.skip_frames([n,time])   <u>跳过一些刚开始不稳定的时候再开始读取图像</u><ul><li>摄像头配置后跳过n帧或者等待时间time让其稳定，n：跳过帧数，time：等待时间，单位ms</li><li>如果n和time均没指定，则默认跳过300ms的帧</li></ul></li><li>sensor.snapshot()     <u>截取sensor摄像头的视频流的当前帧，给img对象</u><ul><li>使用相机拍摄一张照片，并返回image对象</li></ul></li></ul></li></ul><p>time模块：（区别于utime对象(计时器，延时器)，Timer对象(闹钟)）</p><ul><li>构造函数：<ul><li>clock=time.clock()  创建一个闹钟</li></ul></li><li>使用方法：<ul><li>clock.tick()  开始追踪运行时间   <u>更新图像的帧率</u></li><li>clock.fps()  <ul><li>停止追踪运行时间，并返回当前FPS(每秒帧数)</li><li>在调用该函数前始终首先调用tick</li></ul></li></ul></li></ul><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#导入sensor，time模块</span><span class="token keyword">import</span> sensor<span class="token punctuation">,</span>time<span class="token punctuation">,</span>image<span class="token comment" spellcheck="true">#初始化和配置sensor模块</span>sensor<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span>sensor<span class="token punctuation">.</span>set_pixformat<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>RGB565<span class="token punctuation">)</span>snesor<span class="token punctuation">.</span>set_framesize<span class="token punctuation">(</span>QVGA<span class="token punctuation">)</span>sensor<span class="token punctuation">.</span>skip_frames<span class="token punctuation">(</span>time<span class="token operator">=</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#创建一个计时闹钟</span>clock<span class="token operator">=</span>time<span class="token punctuation">.</span>clock<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    clock<span class="token punctuation">.</span>tick<span class="token punctuation">(</span><span class="token punctuation">)</span>    img<span class="token operator">=</span>sensor<span class="token punctuation">.</span>snapstop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>clock<span class="token punctuation">.</span>fps<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h3 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h3><p>“Drawing”—-“…….”</p><p>采集到照片后，我们会进行一些处理，比如在图片某个位置标记箭头，人脸识别后用矩形框提示</p><p>实验目的：在拍摄的图片上画各种图形</p><p>image对象画图功能：</p><ul><li>构造函数：创建图像，通过拍摄或者读取文件路径获取<ul><li>img=sensor.snapshot()</li><li>img=image.Image(path[copy_to_fb=False])<ul><li>copy_to_fb=True:可以加载大图片</li><li>copy_to_fb=False:不可以加载大图片</li></ul></li><li>示例：img=image.Image(“”,copy_to_fb=True)</li></ul></li><li>使用方法：<ul><li>image.draw_line(x0,y0,x1,y1[color[thickness=1]])<ul><li>画线段，(x0,y0)起始坐标，(x1,y1)终点坐标</li><li>color颜色，如(255,0,0)表示红色</li><li>thickness：粗细</li></ul></li><li>image.draw_rectangle(x,y,w,h,[color,[thickness=1,[fill=False]]])<ul><li>画矩形 ，(x,y)起始坐标</li><li>w：宽度，h：长度</li><li>color：颜色</li><li>thickness边框粗细</li><li>fill：是否填冲</li></ul></li><li>image.draw_circle(x,y,radius,[color],[thickness]=1,[fill=False])<ul><li>画圆 (x,y):圆心，radius：半径</li><li>color颜色</li><li>thickness：线条粗细</li><li>fill：是否填冲</li></ul></li><li>image.draw_string(x,y,text,[color],[scale=1],[mono_space=True])<ul><li>写字符 (x,y):起始坐标，text:字符内容</li><li>color：颜色</li><li>scale：字体大小</li><li>mono_space:强制间距</li></ul></li></ul></li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pyb<span class="token punctuation">,</span>time<span class="token punctuation">,</span>sensor<span class="token punctuation">,</span>imagesensor<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span>sensor<span class="token punctuation">.</span>set_pixforamt<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>RGB565<span class="token punctuation">)</span>sensor<span class="token punctuation">.</span>set_framesize<span class="token punctuation">(</span>QVGA<span class="token punctuation">)</span>sensor<span class="token punctuation">.</span>skip_frames<span class="token punctuation">(</span>time<span class="token operator">=</span><span class="token number">2000</span><span class="token punctuation">)</span>clock<span class="token operator">=</span>time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    clock<span class="token punctuation">.</span>tick<span class="token punctuation">(</span><span class="token punctuation">)</span>    img<span class="token operator">=</span>image<span class="token punctuation">.</span>snapshot<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#画线短</span>    img<span class="token punctuation">.</span>draw_line<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>thickness<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#画矩形</span>    img<span class="token punctuation">.</span>draw_rectangle<span class="token punctuation">(</span><span class="token number">150</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>thickness<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>fill<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#画圆</span>    img<span class="token punctuation">.</span>draw_circle<span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">,</span><span class="token number">120</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span>thickness<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>fill<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#写字符</span>    img<span class="token punctuation">.</span>draw_string<span class="token punctuation">(</span><span class="token number">150</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">"1doctorc1"</span><span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span>scale<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>momo_space<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>clock<span class="token punctuation">.</span>fps<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h3 id="特征检测"><a href="#特征检测" class="headerlink" title="特征检测"></a>特征检测</h3><p>特征检测，对图像进行特定的特征检测，如：边缘检测、各种形状识别，特征点识别，线性回归</p><p>特征检测位于Feature–Detection</p><h4 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h4><p>轮廓</p><p>识别摄像头采集的图像轮廓并显示</p><p>重要函数：find_edges,位于image模块下</p><p>边缘处理函数：</p><ul><li>构造函数：image.find_edges(edge_type,[threshold])<ul><li>边缘检测，将图像变为黑白，边缘保留白色像素</li><li>【edge_type】处理方式;<ul><li>image.EDGE_SIMPLE  - 简单的阈值高通滤波算法</li><li>image.EDGE_CANNY  - Canny边缘检测算法</li></ul></li><li>【threshold】包含高、低阈值的二元值，默认是(100,200),仅支持灰度图像</li></ul></li><li>直接调用该函数</li></ul><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#导入sensor等相关模块</span><span class="token keyword">import</span> sensor<span class="token punctuation">,</span>image<span class="token punctuation">,</span>time<span class="token comment" spellcheck="true">#初始化和配置sensor模块</span>sensor<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span>sensor<span class="token punctuation">.</span>set_pixformat<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>RGB565<span class="token punctuation">)</span>sensor<span class="token punctuation">.</span>set_framesize<span class="token punctuation">(</span>QVGA<span class="token punctuation">)</span>sensor<span class="token punctuation">.</span>skip_frames<span class="token punctuation">(</span>time<span class="token operator">=</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#延时让摄像头稳定</span>sensor<span class="token punctuation">.</span>set_gainceiling<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#设置增益，这是官方推荐的参数</span>clock<span class="token operator">=</span>time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    clock<span class="token punctuation">.</span>tick<span class="token punctuation">(</span><span class="token punctuation">)</span>    img<span class="token operator">=</span>sensor<span class="token punctuation">.</span>snapshot<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#拍摄并返回图像</span>    <span class="token comment" spellcheck="true">#使用Canny边缘检测器</span>    image<span class="token punctuation">.</span>find_edges<span class="token punctuation">(</span>image<span class="token punctuation">.</span>EDGE_Canny<span class="token punctuation">,</span>threshold<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#也可以使用简单快速边缘检测</span>    image<span class="token punctuation">.</span>find_edges<span class="token punctuation">(</span>image<span class="token punctuation">.</span>EDGE_SIMPLE<span class="token punctuation">,</span>threshold<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>clock<span class="token punctuation">.</span>fps<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h4 id="图形识别"><a href="#图形识别" class="headerlink" title="图形识别"></a>图形识别</h4><p>示例：圆形</p><p>识别图像中的圆形并用画圆功能指示出来</p><p>重要函数：find_circles位于image模块下</p><p>圆形识别函数：</p><ul><li>image.find_circles(roi[x_stride=2,y=stride=1],threshold=2000,x_margin=10,y_margin=10,r_margin=10,r_min=2,r_max,r_step=2)</li><li>找圆函数，返回一个image.circle圆形对象,该圆形对象有4个值：x,y(圆心)，r(半径),magnitude(量级)：量级越大说明识别到的圆的可信度越高</li><li>【roi】识别区域(x,y,w,h),未指定则默认整张图片</li><li>【threshold】阈值。返回大于或等于threshold的圆，调整识别可信度,</li><li>【x_stride】【y_stride】霍夫变换时跳过x,y像素的量</li><li>【x_margin】【y_margin】【r_margin】控制所检测圆的合并调节</li><li>【r_min】【r_max】控制识别圆形的半径范围</li><li>【r_step】控制识别步骤</li><li>直接调用该函数，大部分参数使用默认</li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> sensor<span class="token punctuation">,</span>image<span class="token punctuation">,</span>timesensor<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span>sensor<span class="token punctuation">.</span>set_pixformat<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>GRAYSCALE<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#</span>sensor<span class="token punctuation">.</span>set_framesize<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>QVGA<span class="token punctuation">)</span>sensor<span class="token punctuation">.</span>skip_frames<span class="token punctuation">(</span>time<span class="token operator">=</span><span class="token number">2000</span><span class="token punctuation">)</span>clock<span class="token operator">=</span>time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    clock<span class="token punctuation">.</span>tick<span class="token punctuation">(</span><span class="token punctuation">)</span>    img<span class="token operator">=</span>sensor<span class="token punctuation">.</span>snapshot<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ens_corr<span class="token punctuation">(</span><span class="token number">1.8</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#lens_corr用于去除畸变</span>    <span class="token comment" spellcheck="true">#threshold数值的提升会降低识别圆形的总数</span>    <span class="token keyword">for</span> c <span class="token keyword">in</span> img<span class="token punctuation">.</span>find_circles<span class="token punctuation">(</span>threshold<span class="token operator">=</span><span class="token number">2000</span><span class="token punctuation">,</span>x_margin<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span>y_margin<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span>r_margin<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span>r_min<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>r_max<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span>r_step<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        img<span class="token punctuation">.</span>draw_circle<span class="token punctuation">(</span>c<span class="token punctuation">.</span>x<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>c<span class="token punctuation">.</span>y<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>c<span class="token punctuation">.</span>r<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>color<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"FPS %f"</span><span class="token operator">%</span>clock<span class="token punctuation">.</span>fps<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>也可用该历程识别<strong>圆形图案</strong>或者<strong>球类物体</strong></p><h4 id="矩形识别"><a href="#矩形识别" class="headerlink" title="矩形识别"></a>矩形识别</h4><p>识别图像中的矩形并用画图功能指示出来</p><p>openmv集成了矩形识别find_rects函数，位于image模块下</p><p>矩形识别函数：</p><ul><li>image.find_rects([roi=Auto],threshold=10000)<ul><li>矩形识别函数，返回一个image.rect矩形对象列表</li><li>【roi】识别区域(x,y,w,h),未指定则默认整张图片</li><li>【threshold】阈值，返回大于或等于threshold的矩形，调整识别可信度</li></ul></li><li>直接调用该函数</li></ul><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#使用quad阈值在图像中找到矩形</span><span class="token comment" spellcheck="true">#四元阈值检测算法检测矩形使用鲁棒的方式</span><span class="token keyword">import</span> sensor<span class="token punctuation">,</span>image<span class="token punctuation">,</span>timesensor<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span>sensor<span class="token punctuation">.</span>set_pixformat<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>RGB565<span class="token punctuation">)</span>sensor<span class="token punctuation">.</span>set_framesize<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>QQVGA<span class="token punctuation">)</span>sensor<span class="token punctuation">.</span>skip_frames<span class="token punctuation">(</span>time<span class="token operator">=</span><span class="token number">2000</span><span class="token punctuation">)</span>clock<span class="token operator">=</span>time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    clock<span class="token punctuation">.</span>tick<span class="token punctuation">(</span><span class="token punctuation">)</span>    img<span class="token operator">=</span>sensor<span class="token punctuation">.</span>snapshot<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> r <span class="token keyword">in</span> img<span class="token punctuation">.</span>find_rexts<span class="token punctuation">(</span>threshold<span class="token operator">=</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        img<span class="token punctuation">.</span>draw_rectangle<span class="token punctuation">(</span>r<span class="token punctuation">.</span>rect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#画矩形显示</span>    <span class="token keyword">for</span> p <span class="token keyword">in</span> r<span class="token punctuation">.</span>corners<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#四角画小圆形</span>        img<span class="token punctuation">.</span>draw_circle<span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"FPS %f"</span> <span class="token operator">%</span> clock<span class="token punctuation">.</span>fps<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h3 id="特征点识别"><a href="#特征点识别" class="headerlink" title="特征点识别"></a>特征点识别</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;openmv机器视觉&quot;&gt;&lt;a href=&quot;#openmv机器视觉&quot; class=&quot;headerlink&quot; title=&quot;openmv机器视觉&quot;&gt;&lt;/a&gt;openmv机器视觉&lt;/h1&gt;&lt;h3 id=&quot;摄像头应用&quot;&gt;&lt;a href=&quot;#摄像头应用&quot; class=&quot;he</summary>
      
    
    
    
    
    <category term="图像识别" scheme="https://1doctorc1.github.io/tags/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>openmv基础实验</title>
    <link href="https://1doctorc1.github.io/2021/03/04/openmv-ji-chu-shi-yan/"/>
    <id>https://1doctorc1.github.io/2021/03/04/openmv-ji-chu-shi-yan/</id>
    <published>2021-03-04T09:52:44.000Z</published>
    <updated>2021-03-04T09:53:08.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="openmv基础实验"><a href="#openmv基础实验" class="headerlink" title="openmv基础实验"></a>openmv基础实验</h1><h3 id="感悟："><a href="#感悟：" class="headerlink" title="感悟："></a>感悟：</h3><p>学会构造函数和使用方法，完成对相关对象的操作</p><p>功能增加就是各类函数的叠加</p><p>除了普通的按键输入和电平检测外，很大一部分输入设备，比如传感器也是通过外部中断方式来实时检测</p><p>I2C学习：使用单片机从0开发需要了解I2C总线原理，了解OLED显示屏的使用手册，编程I2C代码</p><h3 id="历程测试"><a href="#历程测试" class="headerlink" title="历程测试"></a>历程测试</h3><p>通过mircousb数据线将mircopython开发板连接到电脑</p><p>正常操作将会在电脑发现一个U盘</p><p>主要文件介绍：</p><p>main.py： 主函数代码文件，上电后首先执行</p><p>另外系统会自动安装usb转串口驱动，“我的电脑”—“属性”—“设备管理器”—“端口(com和LPT)”查看是否有openMV(cam usb com port)</p><h3 id="点亮led"><a href="#点亮led" class="headerlink" title="点亮led"></a>点亮led</h3><p>通过mircopython对象编程控制，控制led使用到led对象，主要学习led的构造函数和使用方法</p><p>led对象：</p><ul><li>构造函数：pyb.LED(id)    # led对象在pyb模块下</li><li>使用方法：<ul><li>LED.on()      #点亮LED，输出“低”电平？</li><li>LED.off()     #关闭LED，输出“高”电平</li><li>LED.toggle()  #LED亮灭状态翻转，输出电平翻转</li></ul></li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pyb <span class="token keyword">import</span> LED    <span class="token comment" spellcheck="true">#导入模块</span>LED<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span>on<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#令LED3(蓝)亮</span></code></pre><p>需要加载到openmv4文件系统，无法在openmvIDE中运行，因为无while True()死循环</p><h3 id="流水灯"><a href="#流水灯" class="headerlink" title="流水灯"></a>流水灯</h3><p>要实现固定时间来亮灭，需要用到utime模块中的延时函数</p><p>utime时间对象：</p><ul><li>utime()   #时间模块</li><li>使用方法：<ul><li>utime.sleep_ms(ms)   # 毫秒级延时</li><li>utime.sleep_us(us)   #微妙级延时</li></ul></li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pyb <span class="token keyword">import</span> LED<span class="token keyword">import</span> utime<span class="token comment" spellcheck="true">#关闭全部LED</span>LED<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>off<span class="token punctuation">(</span><span class="token punctuation">)</span>LED<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span>off<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#while True 表示一直循环</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#LED2亮1秒</span>    LED<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>on<span class="token punctuation">(</span><span class="token punctuation">)</span>    utime<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    LED<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>off<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#LED3亮1秒</span>    LED<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span>on<span class="token punctuation">(</span><span class="token punctuation">)</span>    utime<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    LED<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span>off<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#for形式实现上述功能</span><span class="token keyword">from</span> pyb <span class="token keyword">import</span> LED<span class="token keyword">import</span> utime<span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    LED<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>off<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        LED<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>on<span class="token punctuation">(</span><span class="token punctuation">)</span>        utime<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        LED<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>off<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="GPIO-按键"><a href="#GPIO-按键" class="headerlink" title="GPIO(按键)"></a>GPIO(按键)</h3><p>General  Purpose Input/Output</p><p>GPIO(Pin对象)的构造函数和使用方法：</p><ul><li>构造函数：<ul><li>pyb.Pin(id,mode,pull_mode)</li><li>Pin对象在pyb模块下</li><li>【id】引脚号，P0，P1</li><li>【mode】输入输出模式选择    Pin.IN输入模式，Pin.OUT_PP输出带推挽</li><li>【pull_mode】上下拉电阻配置     Pin.PULL_UP上拉电阻    Pin.PULL_DOWN下拉电阻   Pin.PULL_NONE没上下拉电阻</li><li>例：KEY=Pin(“P9”,Pin.IN,Pin.PULL_UP)   #将按键P9配置为输入方式</li></ul></li><li>使用方法：<ul><li>Pin.high()   引脚输出高电平</li><li>Pin.low()   引脚输出低电平</li><li>Pin.value()  获取当前引脚的输入电平，返回0(低电平)或者1(高电平)</li></ul></li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pyb <span class="token keyword">import</span> LED<span class="token punctuation">,</span>Pin<span class="token comment" spellcheck="true">#配置KEY</span>KEY<span class="token operator">=</span>Pin<span class="token punctuation">(</span><span class="token string">"P9"</span><span class="token punctuation">,</span>Pin<span class="token punctuation">.</span>IN<span class="token punctuation">,</span>Pin<span class="token punctuation">.</span>PULL_UP<span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> KEY<span class="token punctuation">.</span>value<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span> <span class="token punctuation">:</span>        LED<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>on<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        LED<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>off<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h3><p>上述代码会使GPIO口一直检测IO的输入口变化</p><p>外部中断要实现：当按键被按下(产生中断)时，我们才去执行相关功能</p><p>外部中断对象：</p><ul><li>构造函数:<ul><li>pyb.ExtInt(pin,mode,pull_mode,callback)</li><li>【pin】引脚号</li><li>【mode】中断触发方式   Extlnt.IRQ_RISING:上升沿触发    Extlnt.IRQ_FALLING:下降沿触发   Extlnt.IRQ_RISING_FALLING: 上升或下降沿触发</li><li>【pull_mode】上下拉电阻设置，同Pin对象构造函数</li><li>【callback】中断后执行的回调函数</li></ul></li></ul><p>上升沿和下降沿：</p><p><img src="C:\Users\张驰\AppData\Roaming\Typora\typora-user-images\image-20210205110519548.png" alt="image-20210205110519548"></p><p>当按键被按下再松开时，引脚先获得下降沿再获得上升沿</p><p>因此可以选择下降沿方式触发外部中断</p><p>实验目的：利用中断方式检查按键KEY状态，按键被按下(产生外部中断)后使LED(2)蓝灯的亮灭状态发转</p><ol><li>导入模块</li><li>配置中断方式和定义回调函数</li><li>产生外部中断的时候自动执行回调函数</li></ol><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pyb <span class="token keyword">import</span> LED<span class="token punctuation">,</span>Pin<span class="token punctuation">,</span>ExtIntcallback<span class="token operator">=</span><span class="token keyword">lambda</span> e<span class="token punctuation">:</span>LED<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span>toggle<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#下降沿触发，拉开上拉电阻</span>ext<span class="token operator">=</span>ExtInt<span class="token punctuation">(</span>Pin<span class="token punctuation">(</span><span class="token string">'P9'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>ExtInt<span class="token punctuation">.</span>IRQ_FALLING<span class="token punctuation">,</span>Pin<span class="token punctuation">.</span>PULL_UP<span class="token punctuation">,</span>callback<span class="token punctuation">)</span></code></pre><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>通过定时器可以完成各种预设好的任务</p><p>实验通过定时器让LED(3)蓝灯周期性每秒闪烁1次</p><p>定时器对象：</p><ul><li>构造函数：<ul><li>pyb.Timer(id,freq,……)</li><li>定时器对象Timer对象在pyb模块下</li><li>【id】定时器编号，1–14</li><li>【freq】定时器中断频率</li></ul></li><li>Timer.callback(fun)    定义执行的回调函数</li><li>Timer.deinit()   终止定时器</li></ul><ol><li>导入模块</li><li>定义回调函数和配置定时器中断方式</li><li>当定时器产生中断时候自动执行回调函数</li></ol><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pyb <span class="token keyword">import</span> Timer<span class="token punctuation">,</span>LEDtimer<span class="token operator">=</span>Timer<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span>freq<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#使用定时器4创建定时器对象，频率1HZ</span><span class="token comment" spellcheck="true">#定时器中断回调函数，执行LED(3)蓝灯状态反转</span>timer<span class="token punctuation">.</span>callback<span class="token punctuation">(</span><span class="token keyword">lambda</span> t<span class="token punctuation">:</span>LED<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span>toggle<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h3 id="I2C总线-OLED屏"><a href="#I2C总线-OLED屏" class="headerlink" title="I2C总线(OLED屏)"></a>I2C总线(OLED屏)</h3><p>输出设备OLED</p><p>pyAI-Openmv4是通过I2C总线与OLED显示屏通讯的</p><p>I2C是不同通讯设备之间的通讯协议，在物理层面分为两条线，SCL和SDA，即时钟线和数据线</p><p>OLED与py板的连接：Y6–SCL，Y8–SDA</p><p>openmv4与py板的连接：Y6–P2，Y8–P0</p><p>即Openmv4与OLED的对应连接关系是： P0–SDA，P2–SCL</p><p>I2C对象： </p><ul><li>构造函数：i2c=machine.I2C(scl,sda,freq)     构造I2C对象<ul><li>【scl】时钟引脚</li><li>【sda】数据引脚</li><li>【freq】通信频率，即速度</li></ul></li><li>使用方法<ul><li>i2c.scan()  扫描I2C总线的设备，返回地址</li><li>i2c.readfrom(addr,nbytes)  从指定地址读数据  addr：指定设备地址，nbytes：读取字节数</li><li>i2c.write(buf)   写数据  buf:数据内容</li></ul></li></ul><p>OLED对象：</p><ul><li>构造函数：oled=SSD1306_I2C(width,height,i2c,addr)<ul><li>构造OLED显示屏对象</li><li>【width】屏幕宽像素</li><li>【height】屏幕高像素</li><li>【i2c】定义好的I2c对象</li><li>【addr】显示屏设备地址</li></ul></li><li>使用方法：<ul><li>oled.text(string,x,y)   将string字符写在指定位置，string：字符；x：横坐标，y：纵坐标</li><li>oled.show()  执行显示</li><li>oled.fill(RGB)  清屏，RGB：0表示黑色，1表示白色</li></ul></li></ul><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#导入Pin，I2C，OLED模块</span><span class="token keyword">from</span> pyb <span class="token keyword">import</span> Pin<span class="token keyword">from</span> ssd1306<span class="token punctuation">.</span>py <span class="token keyword">import</span> OLED<span class="token keyword">from</span> machine <span class="token keyword">import</span> I2C<span class="token comment" spellcheck="true">#初始化I2C和OLED</span>i2c<span class="token operator">=</span>machine<span class="token punctuation">.</span>I2C<span class="token punctuation">(</span><span class="token string">"P2"</span><span class="token punctuation">,</span><span class="token string">"P0"</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span>oled<span class="token operator">=</span>SSD1306_I2C<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span>i2c<span class="token punctuation">,</span>i2c<span class="token punctuation">.</span>scan<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#输入需要显示的字符</span>oled<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#执行OLED显示函数</span>oled<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">from</span> machine <span class="token keyword">import</span> I2C<span class="token punctuation">,</span>Pin      <span class="token comment" spellcheck="true">#从machine模块导入I2C，Pin子模块</span><span class="token keyword">from</span> ssd1306 <span class="token keyword">import</span> SSD1306_I2C  <span class="token comment" spellcheck="true">#从ssd1306模块中导入SSD1306_I2C子模块</span><span class="token comment" spellcheck="true">#I2C初始化</span>i2c<span class="token operator">=</span>I2C<span class="token punctuation">(</span>sda<span class="token operator">=</span>Pin<span class="token punctuation">(</span><span class="token string">"P0"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>scl<span class="token operator">=</span>Pin<span class="token punctuation">(</span><span class="token string">"P2"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>freq<span class="token operator">==</span><span class="token number">80000</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#OLED显示屏初始化：128*64分辨率，OLED的I2C地址是0x3c</span>oled<span class="token operator">=</span>SSD1306_I2C<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">,</span><span class="token number">64</span><span class="token punctuation">,</span>i2c<span class="token punctuation">,</span>addr<span class="token operator">=</span><span class="token number">0x3c</span><span class="token punctuation">)</span>oled<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#写入第1行内容</span>oled<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token string">"MircoPython"</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#写入第2行内容</span>oled<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#oled执行显示</span></code></pre><h3 id="RTC实时时钟"><a href="#RTC实时时钟" class="headerlink" title="RTC实时时钟"></a>RTC实时时钟</h3><p>学习RTC编程并制作电子时钟(读取RTC数据)，使用OLED显示</p><p>pyboard集成了内置时钟函数模块</p><p>RTC实时时钟对象：</p><ul><li>构造函数：pyb.RTC()  RTC()是内置的实时时钟函数模块</li><li>使用方法：RTC().datetime(2019,4,1,1,0,0,0,0)<ul><li>设置日期时间：顺序分别是年，月，日，星期，时，分，秒，次秒级</li><li>星期：1-7表示周一到周日</li><li>次秒级：255–0倒着计数</li><li>RTC().datetime()   获取当前日期时间数据</li></ul></li></ul><p>先设定时间，然后获取当前芯片里的时间，通过OLED显示屏显示，如此循环</p><p>每隔一段时间获取一次数据，可以每隔300ms获取一次数据</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#导入RTC，OLED模块</span><span class="token keyword">from</span> pyb <span class="token keyword">import</span> RTC<span class="token keyword">from</span> ssd1306 <span class="token keyword">import</span> SSD1306_I2C<span class="token comment" spellcheck="true">#初始化RTC和OLED</span>oled<span class="token operator">=</span>SSD1306_I2C<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">,</span><span class="token number">64</span><span class="token punctuation">,</span>i2c<span class="token punctuation">,</span>addr<span class="token operator">=</span><span class="token number">0x3c</span><span class="token punctuation">)</span>rtc<span class="token operator">=</span>RTC<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2021</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    trc<span class="token operator">=</span>RTC<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>datatime<span class="token punctuation">(</span><span class="token punctuation">)</span>    oled<span class="token punctuation">.</span>text<span class="token punctuation">(</span>rtc<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>    oled<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>    utime<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#导入相关模块</span><span class="token keyword">from</span> pyb <span class="token keyword">import</span> RTC<span class="token keyword">from</span> machine <span class="token keyword">import</span> Pin<span class="token punctuation">,</span>I2C<span class="token keyword">from</span> ssd1306 <span class="token keyword">import</span> SSD13066_I2C<span class="token keyword">import</span> utime<span class="token comment" spellcheck="true">#定义星期和时间(时分秒)显示字符列表</span>week<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'Mon'</span><span class="token punctuation">,</span><span class="token string">'Tues'</span><span class="token punctuation">,</span><span class="token string">'Wed'</span><span class="token punctuation">,</span><span class="token string">'Thur'</span><span class="token punctuation">,</span><span class="token string">'Fri'</span><span class="token punctuation">,</span><span class="token string">'Sat'</span><span class="token punctuation">,</span><span class="token string">'Sun'</span><span class="token punctuation">]</span>time<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">''</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#初始化所有相关对象</span>i2c<span class="token operator">=</span>I2C<span class="token punctuation">(</span>sda<span class="token operator">=</span>Pin<span class="token punctuation">(</span><span class="token string">'P0'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>scl<span class="token operator">=</span>Pin<span class="token punctuation">(</span><span class="token string">"P2"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>freq<span class="token operator">=</span><span class="token number">80000</span><span class="token punctuation">)</span>oled<span class="token operator">=</span>SSD1306_I2C<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">,</span><span class="token number">64</span><span class="token punctuation">,</span>i2c<span class="token punctuation">,</span>addr<span class="token operator">=</span><span class="token number">0x3c</span><span class="token punctuation">)</span>rtc<span class="token operator">=</span>RTC<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#设置初始时间</span>rtc<span class="token punctuation">.</span>datatime<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2021</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    datetime<span class="token operator">=</span>rtc<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#获取当前时间</span>    oled<span class="token punctuation">.</span>fill<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#清屏显示黑色背景</span>    <span class="token comment" spellcheck="true">#显示日期，字符串使用“+”连接</span>    oled<span class="token punctuation">.</span>text<span class="token punctuation">(</span>str<span class="token punctuation">(</span>datetime<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"-"</span><span class="token operator">+</span>str<span class="token punctuation">(</span>datetime<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"-"</span><span class="token operator">+</span>str<span class="token punctuation">(</span>datetime<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span><span class="token string">" "</span>week<span class="token punctuation">[</span><span class="token punctuation">(</span>datetime<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#显示时间</span>    oled<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>    utime<span class="token punctuation">.</span>sleep_ms<span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span></code></pre><h3 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h3><p>analog  to  digital  conversion  模拟数字转换</p><p>将模拟信号转化成数字信号</p><p>应用：将外界模拟信号通过ADC转换成单片机可以识别的数字信息</p><p>将变化的电压转成数字信号</p><p>实验目的：调用mircopython内置的ADC函数，实现测量0-3.3V电压，并显示到OLED屏幕上</p><p>openmv的P6引脚连接到pyboard的X6上，通过跳线帽连接X6和X7，pyboard上的X7用于调节电压</p><p>ADC对象：</p><ul><li>构造函数：<ul><li>pyb.ADC(Pin)  ADC对象在pyb模块下，Pin:ADC输入引脚</li></ul></li><li>使用方法：<ul><li>ADC.read()</li><li>读取AD值，返回0–4095(0V–3.3V),自带ADC的测量精度是12位，2^12=4096</li></ul></li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pyb <span class="token keyword">import</span> ADC<span class="token punctuation">,</span>Pin<span class="token keyword">from</span> machine <span class="token keyword">import</span> I2C<span class="token keyword">from</span> ssd1306x <span class="token keyword">import</span> SSD1306_I2C<span class="token keyword">import</span> utime<span class="token comment" spellcheck="true">#初始化ADC和OLED</span>adc<span class="token operator">=</span>ADC<span class="token punctuation">(</span><span class="token string">"P"</span><span class="token punctuation">)</span>i2c<span class="token operator">=</span>machine<span class="token punctuation">.</span>I2C<span class="token punctuation">(</span>scl<span class="token operator">=</span>Pin<span class="token punctuation">(</span><span class="token string">"P2"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>sda<span class="token operator">=</span>Pin<span class="token punctuation">(</span><span class="token string">"P0"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>freq<span class="token operator">=</span><span class="token number">80000</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#!!!!</span>oled<span class="token operator">=</span>SSD1306_I2C<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">,</span><span class="token number">64</span><span class="token punctuation">,</span>i2c<span class="token punctuation">,</span>ox3c<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#获取ADC的值</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>          <span class="token comment" spellcheck="true">#!!!!</span>    vcc<span class="token operator">=</span>adc<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">1240</span>    oled<span class="token punctuation">.</span>text<span class="token punctuation">(</span>str<span class="token punctuation">(</span>vcc<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>    utime<span class="token punctuation">.</span>sleep_ms<span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#导入相关模块</span><span class="token keyword">import</span> pyb<span class="token punctuation">,</span>utime<span class="token keyword">from</span> machine <span class="token keyword">import</span> Pin<span class="token punctuation">,</span>I2C<span class="token keyword">from</span> ssd1306x <span class="token keyword">import</span> SSD1306_I2C<span class="token comment" spellcheck="true">#初始化相关模块</span>i2c<span class="token operator">=</span>I2C<span class="token punctuation">(</span>sda<span class="token operator">=</span>Pin<span class="token punctuation">(</span><span class="token string">"P0"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>scl<span class="token operator">=</span>Pin<span class="token punctuation">(</span><span class="token string">"P2"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>freq<span class="token operator">=</span><span class="token number">80000</span><span class="token punctuation">)</span>oled<span class="token operator">=</span>SSD1306_I2C<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">,</span><span class="token number">64</span><span class="token punctuation">,</span>i2c<span class="token punctuation">,</span>addr<span class="token operator">=</span><span class="token number">0x3c</span><span class="token punctuation">)</span>adc<span class="token operator">=</span>pyb<span class="token punctuation">.</span>ADC<span class="token punctuation">(</span><span class="token string">"P6"</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    oled<span class="token punctuation">.</span>fill<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#每次使用前都要清屏，以显示黑色背景</span>    oled<span class="token punctuation">.</span>text<span class="token punctuation">(</span>str<span class="token punctuation">(</span>adc<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">)</span>    oled<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token string">'(4095)'</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">)</span>    oled<span class="token punctuation">.</span>text<span class="token punctuation">(</span>str<span class="token punctuation">(</span><span class="token string">'%.2f'</span><span class="token operator">%</span><span class="token punctuation">(</span>adc<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">4095</span><span class="token operator">*</span><span class="token number">3.3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span>    oled<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token string">'V'</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">55</span><span class="token punctuation">)</span>    oled<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>    utime<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></code></pre><h3 id="DAC"><a href="#DAC" class="headerlink" title="DAC"></a>DAC</h3><p>digital  to  analog  converter数字模拟转化器</p><p>将特定的数字信号通过DAC输出，输出的形式多种，特定电压，信号波形</p><p>实验目的：通过DAC输出不同频率的方波来驱动蜂鸣器</p><p>pybase开发板X5引脚连接无源蜂鸣器</p><p>openmv4的DAC引脚P6连接到pybase开发板的X6引脚</p><p>用跳线帽连接pybase开发板的X5和X6引脚</p><p>DAC对象：</p><ul><li>构造函数：<ul><li>pyb.DAC(port,bits=8)    DAC对象在pyb模块下</li><li>【port】对应“P6”</li><li>【bits】8或者12</li></ul></li><li>使用方法：<ul><li>DAC.noise(freq)  产生特定频率的噪声信号</li><li>DAC.triangel(freq)  产生特定频率的三角波信号</li><li>DAC.write(value)   输出特定电压(0–VCC)    【value】范围：0–2^bits-1(例如8bits那么范围就是0–255)</li><li>DAC.write_timed(data,freq,mode)【data】字节数组  【freq】频率输出   【mode】模式：DAC.NORMAL单次模式，DAC.CIRCULAR循环模式</li></ul></li></ul><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#导入ADC，KEY，OLED模块</span><span class="token keyword">from</span> pyb <span class="token keyword">import</span> Pin<span class="token punctuation">,</span>ADC<span class="token keyword">from</span> ssd1306x <span class="token keyword">import</span> SSD1306_I2C<span class="token keyword">from</span> machine <span class="token keyword">import</span> I2C<span class="token comment" spellcheck="true">#初始化相关模块</span>key<span class="token operator">=</span>Pin<span class="token punctuation">(</span><span class="token string">"P6"</span><span class="token punctuation">,</span>Pin<span class="token punctuation">.</span>IN<span class="token punctuation">.</span>Pin<span class="token punctuation">.</span>PULL_UP<span class="token punctuation">)</span>dac<span class="token operator">=</span>DAC<span class="token punctuation">(</span><span class="token string">"P6"</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span>i2c<span class="token operator">=</span>machine<span class="token punctuation">.</span>I2C<span class="token punctuation">(</span>scl<span class="token operator">=</span>Pin<span class="token punctuation">(</span><span class="token string">"P2"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>sda<span class="token operator">=</span>Pin<span class="token punctuation">(</span><span class="token string">"P0"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>freq<span class="token operator">=</span><span class="token number">80000</span><span class="token punctuation">)</span>oled<span class="token operator">=</span>SSD1306_I2C<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">,</span><span class="token number">64</span><span class="token punctuation">,</span>i2c<span class="token punctuation">,</span><span class="token number">0x3c</span><span class="token punctuation">)</span><span class="token keyword">if</span> key<span class="token punctuation">.</span>value<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        dac<span class="token punctuation">.</span>write_timed<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>DAC<span class="token punctuation">.</span>CIRCULAR<span class="token punctuation">)</span>        oled<span class="token punctuation">.</span>text<span class="token punctuation">(</span>str<span class="token punctuation">(</span>dac<span class="token punctuation">.</span>write_timed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">from</span> pyb <span class="token keyword">import</span> ADC<span class="token punctuation">,</span>ExtInt<span class="token keyword">from</span> ssd1306x <span class="token keyword">import</span> ssd1306_I2C<span class="token keyword">from</span> machine <span class="token keyword">import</span> I2Ci2c<span class="token operator">=</span>I2C<span class="token punctuation">(</span>scl<span class="token operator">=</span>Pin<span class="token punctuation">(</span><span class="token string">"P2"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>sda<span class="token operator">=</span>Pin<span class="token punctuation">(</span><span class="token string">"P0"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>freq<span class="token operator">=</span><span class="token number">80000</span><span class="token punctuation">)</span>oled<span class="token operator">=</span>SSD1306_I2C<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">,</span><span class="token number">64</span><span class="token punctuation">,</span>i2c<span class="token punctuation">,</span><span class="token number">0x3c</span><span class="token punctuation">)</span>dac<span class="token operator">=</span>DAC<span class="token punctuation">(</span>Pin<span class="token punctuation">(</span><span class="token string">"P6"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>freq<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">5000</span><span class="token punctuation">]</span>buf<span class="token operator">=</span>bytearray<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>buf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">255</span>key_node<span class="token operator">=</span><span class="token number">0</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token keyword">def</span> <span class="token function">key</span><span class="token punctuation">(</span>ext<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> key_node    key_node<span class="token operator">=</span><span class="token number">1</span>ext<span class="token operator">=</span>ExtInt<span class="token punctuation">(</span>Pin<span class="token punctuation">(</span><span class="token string">"P9"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>ExtInt<span class="token punctuation">.</span>IRQ_FALLING<span class="token punctuation">,</span>Pin<span class="token punctuation">.</span>PULL_UP<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token number">1</span>oled<span class="token punctuation">.</span>fill<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>oled<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> key_node<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>        i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span>        <span class="token keyword">if</span> i<span class="token operator">==</span><span class="token number">4</span><span class="token punctuation">:</span>            i<span class="token operator">=</span><span class="token number">0</span>        key_node<span class="token operator">=</span><span class="token number">0</span>        dac<span class="token punctuation">.</span>write_timed<span class="token punctuation">(</span>buf<span class="token punctuation">,</span>freq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>len<span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span>mode<span class="token operator">=</span>DAC<span class="token punctuation">.</span>CIRCULAR<span class="token punctuation">)</span>        oled<span class="token punctuation">.</span>text<span class="token punctuation">(</span>str<span class="token punctuation">(</span>freq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"Hz"</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">)</span>        oled<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;openmv基础实验&quot;&gt;&lt;a href=&quot;#openmv基础实验&quot; class=&quot;headerlink&quot; title=&quot;openmv基础实验&quot;&gt;&lt;/a&gt;openmv基础实验&lt;/h1&gt;&lt;h3 id=&quot;感悟：&quot;&gt;&lt;a href=&quot;#感悟：&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="图像识别" scheme="https://1doctorc1.github.io/tags/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>STL常用容器3</title>
    <link href="https://1doctorc1.github.io/2021/03/04/stl-chang-yong-rong-qi-3/"/>
    <id>https://1doctorc1.github.io/2021/03/04/stl-chang-yong-rong-qi-3/</id>
    <published>2021-03-04T09:51:17.000Z</published>
    <updated>2021-03-04T09:51:17.317Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>STL常用容器2</title>
    <link href="https://1doctorc1.github.io/2021/03/04/stl-chang-yong-rong-qi-2/"/>
    <id>https://1doctorc1.github.io/2021/03/04/stl-chang-yong-rong-qi-2/</id>
    <published>2021-03-04T09:50:08.000Z</published>
    <updated>2021-03-04T09:50:38.710Z</updated>
    
    <content type="html"><![CDATA[<p>STL常用容器2</p><p>STL是低阶码农的归宿。—《不知名弹幕》</p><p>推荐赫斌老师的数据结构。  —《某不知名弹幕》</p><p>STL中List和vector是两个最常被使用的容器</p><h2 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h2><p><img src="C:\Users\张驰\AppData\Roaming\Typora\typora-user-images\image-20210301110110707.png" alt="image-20210301110110707"></p><ul><li>前端封闭，不可以从前端插入数</li><li><code>front()//首个元素</code></li><li><code>back()//最后一个元素</code></li><li><code>push_back()//尾插</code></li><li><code>pop_back()//删除尾部数据</code></li><li><code>v.begin()//第一个元素的位置</code></li><li><code>v.rbegin()//最后一个元素的位置</code></li><li><code>v.end()//最后一个元素的下一个位置</code></li><li><code>v.rend()//第一个元素的前一个位置</code></li><li><code>insert()//插入</code></li></ul><p>vector可以视作数组，但是和数组有区别</p><p>数组的空间大小在程序运行前就已经分配完成，是静态空间</p><p>而vector可以动态拓展，动态拓展不是指在原有的内存空间续借空间，而是指将数据拷贝到更大的内存空间，删除原内存空间数据</p><p>vector容器支持可随机访问的迭代器，类似于数组的访问</p><p>迭代器：<code>vector&lt;T&gt;::iterator</code></p><h3 id="vector构造函数"><a href="#vector构造函数" class="headerlink" title="vector构造函数"></a>vector构造函数</h3><p>函数原型：</p><ul><li><p><code>vector&lt;T&gt; v;</code>//采用模板实现  类实现，默认构造函数</p></li><li><p><code>vector(v.begin(),v.end());</code>//将<strong>v[v.begin(),v.end())区间</strong>中的数据拷贝到本身，无需模板指定数据类型</p><ul><li>这个区间，前闭后开，即前面的数据可以取到，但是后面的数据无法取到，end指向的值是无意义的</li></ul></li><li><p><code>vector(const vector &amp;vec);</code>//拷贝构造函数</p></li></ul><pre class=" language-c++"><code class="language-c++">void printv(vector<int>& v)  //const vector<int>& v&#123;    for (vector<int>::iterator it = v.begin(); it != v.end(); it++)        cout << (*it);    cout << endl;&#125;void test01()&#123;    vector<int> v1;    for (int i = 0; i < 10; i++)    &#123;        v1.push_back(i);    &#125;    printv(v1);    //vector<int> v2=(v1.begin(), v1.end());    vector<int> v2(v1.begin(), v1.end());    printv(v2);    vector<int> v3(10, 100);  //前一个参数为数量，后一个参数为单个数据    printv(v3);    vector<int> v4 = v3;    printv(v4);&#125;=>    0123456789    0123456789    100100100100100100100100100100    100100100100100100100100100100</code></pre><h3 id="vector赋值操作"><a href="#vector赋值操作" class="headerlink" title="vector赋值操作"></a>vector赋值操作</h3><p>函数原型：</p><ul><li><code>vector&amp; operator=(const vector &amp;vec);</code>//重载等号操作符</li><li><code>assign(beg,end);</code>//将[beg,end）区间中的数据拷贝赋值给本身</li><li><code>assign(n,elem);</code>//将n个elem拷贝赋值给本身</li></ul><pre class=" language-c++"><code class="language-c++">void test02()&#123;    //vector赋值    vector<int> v1;    for (int i = 0; i < 10; i++)    &#123;        v1.push_back(i);    &#125;    vector<int> v2;    v2 = v1;        //no.1    printv(v2);    vector<int> v3;    v3.assign(v1.begin(), v1.end());   //no.2    printv(v3);    vector<int> v4;    v4.assign(2, 829);    //no.3    printv(v4);&#125;=>    0123456789    0123456789    829829</code></pre><h3 id="vector容量和大小"><a href="#vector容量和大小" class="headerlink" title="vector容量和大小"></a>vector容量和大小</h3><p>函数原型：</p><ul><li><code>empty();//判断容器是否为空，为空返回1</code></li><li><code>capacity();//容器的容量</code></li><li><code>size();//返回容器中元素的个数</code></li><li><code>resize(int num);//重新指定容器的大小，如果容器变长，则以默认值填冲新位置，如果变短，末尾超出容器长度的元素被删除</code></li><li><code>resize(int num,elem);//同上，多出的用elem填充</code></li></ul><pre class=" language-c++"><code class="language-c++">void test03()&#123;    //vector容器的容量和大小    vector<int> v;    for (int i = 0; i < 10; i++)    &#123;        v.push_back(i);    &#125;    if (v.empty())    &#123;        cout << "v为空";    &#125;    else    &#123;        cout << v.capacity() << endl;//容量        cout << v.size() << endl;//元素个数    &#125;    v.resize(15, 10);    printv(v);    v.resize(5);    printv(v);&#125;=>    13    10    01234567891010101010    01234</code></pre><h3 id="vector插入和删除"><a href="#vector插入和删除" class="headerlink" title="vector插入和删除"></a>vector插入和删除</h3><p>函数原型：</p><ul><li><code>push_back(ele);//尾部插入元素ele</code></li><li><code>pop_back();//尾部删除元素</code></li><li><code>insert(const_iterator pos,ele);//迭代器指向位置pos插入元素ele</code></li><li><code>insert(const_iterator pos,int count,ele);//迭代器指向位置插入n个ele元素</code></li><li><code>erase(const_iterator pos);//删除迭代器指向的元素</code></li><li><code>erase(const_iterator start,const_iterator end);//删除迭代器从start到end之间的元素</code></li><li><code>clear();//删除容器中的所有元素</code></li></ul><pre class=" language-c++"><code class="language-c++">void test04()&#123;    //vector的插入和删除    vector<int> v;    v.push_back(10);    v.push_back(20);    v.push_back(30);    v.push_back(40);    printv(v);    v.pop_back();    printv(v);    //v.insert(2, 30);    v.insert(v.begin(), 0);    v.insert(v.end(), 3, 50);    printv(v);    v.erase(v.begin());    printv(v);    v.clear();    printv(v);&#125;=>    10203040    102030    0102030505050    102030505050</code></pre><h3 id="vector数据存取"><a href="#vector数据存取" class="headerlink" title="vector数据存取"></a>vector数据存取</h3><p>函数原型：</p><ul><li>at(int idx);//返回索引idx所指的数据</li><li>operator[];//返回索引idx所指的数据</li><li>front();//返回容器中第一个数据元素</li><li>back();//返回容器中最后一个数据元素</li></ul><pre class=" language-c++"><code class="language-c++">void test05()&#123;    //vector的存取    vector<int> v;    v.push_back(10);    v.push_back(20);    v.push_back(30);    v.push_back(40);    cout<<v.at(1);    cout << v[2];    cout << v.front();    cout << v.back();&#125;=>    20301040</code></pre><h3 id="vector互换容器"><a href="#vector互换容器" class="headerlink" title="vector互换容器"></a><strong><u>vector互换容器</u></strong></h3><h3 id="vector预留空间"><a href="#vector预留空间" class="headerlink" title="vector预留空间"></a><strong><u>vector预留空间</u></strong></h3><h2 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>双端数组，可以对头部进行插入删除操作</p><p><img src="C:\Users\张驰\AppData\Roaming\Typora\typora-user-images\image-20210301143519206.png" alt="image-20210301143519206"></p><p>deque容器的迭代器也是支持随机访问的</p><p>deque容器的迭代器：<code>deque&lt;int&gt;::const_iterator</code></p><p>迭代器访问：</p><pre class=" language-c++"><code class="language-c++">void printd(deque<int>& d)&#123;    //for(deque<T>::const_iterator it=)    for (deque<int>::const_iterator it = d.begin(); it != d.end(); it++)        cout << (*it);&#125;</code></pre><h3 id="deque构造函数"><a href="#deque构造函数" class="headerlink" title="deque构造函数"></a>deque构造函数</h3><ul><li><code>deque&lt;T&gt;;//默认构造形式</code></li><li><code>deque(beg,end);//构造函数将[beg,end)区间中的元素拷贝到容器中</code></li><li><code>deque(n,elem);//构造函数将n个elem拷贝给本身</code></li><li><code>deque(const deque&amp;deq);//构造拷贝函数</code></li></ul><pre class=" language-c++"><code class="language-c++">void test01()&#123;    deque<int> d1;    d1.push_back(10);    d1.push_front(20);    deque<int> d2(d1.begin(), d1.end());    deque<int> d3(3, 30);    deque<int> d4 = d3;    printd(d1); cout << endl;    printd(d2); cout << endl;    printd(d3); cout << endl;    printd(d4);&#125;=>    2010    2010    303030    303030</code></pre><p>deque容器和vector容器的构造方式几乎一致</p><h3 id="deque赋值操作"><a href="#deque赋值操作" class="headerlink" title="deque赋值操作"></a>deque赋值操作</h3><p>函数原型：</p><ul><li><code>deque&amp; operator=(const deque&amp; deq);</code></li><li><code>deque.assign(beg,end);</code></li><li><code>deque.assign(n,elem);</code></li></ul><h3 id="deque大小操作"><a href="#deque大小操作" class="headerlink" title="deque大小操作"></a>deque大小操作</h3><p>函数原型:</p><ul><li><p><code>deque.empty();</code></p></li><li><p><code>deque.size();</code></p></li><li><p><code>deque.resize(int num);</code></p></li><li><p><code>deque.resize(int num,elem);</code></p></li></ul><p><strong>deque没有容量的概念</strong></p><h3 id="deque插入和删除"><a href="#deque插入和删除" class="headerlink" title="deque插入和删除"></a>deque插入和删除</h3><p>函数原型：</p><ol><li>两端插入操作：</li></ol><ul><li><p><code>push_back();//尾插</code></p></li><li><p><code>pop_back();//尾删</code></p></li><li><p><code>push_front();//头插</code></p></li><li><p><code>pop_front();//头删</code></p></li></ul><ol start="2"><li>指定位置操作：</li></ol><ul><li><code>insert(pos,elem);//在pos位置插入elem的拷贝，返回该数据的位置</code></li><li><code>insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值</code></li><li><code>insert(pos,begin,end);//在pos位置插入区间[beg,end)中的数据，无返回值</code></li><li><code>clear();//清空容器中的数据</code></li><li><code>erase(pos);//删除pos位置的数据，返回下一个数据的位置</code></li><li><code>erase(begin,end);//删除[begin,end)区间中的数据,返回下一个数据的位置</code></li></ul><p><strong>插入和删除提供的位置不是元素序号或者下标，而是迭代器位置</strong></p><h3 id="deque数据存取"><a href="#deque数据存取" class="headerlink" title="deque数据存取"></a>deque数据存取</h3><p>函数原型：</p><ul><li><code>at(int idx);//返回索引idx所指的数据</code></li><li><code>operator[];//返回索引idx所指的数据</code></li><li><code>front();//返回容器第一个数据</code></li><li><code>back();//返回容器最后一个数据</code></li></ul><h3 id="deque排序"><a href="#deque排序" class="headerlink" title="deque排序"></a>deque排序</h3><p>利用算法对deque容器进行排序，类似于vector容器中常用的算法<code>for_each(begin,end,func);</code></p><p>deque容器排序算法：</p><p><code>sort(iterator begin,iterator end);//对beg和end区间内元素进行排序</code></p><pre class=" language-c++"><code class="language-c++">#include<algorithm>void test02()&#123;    deque<int> d;    d.push_back(10);    d.push_front(20);    d.push_front(30);    d.push_back(40);    printd(d); cout << endl;    sort(d.begin(), d.end());    printd(d);&#125;//sort从小到大排序=>    30201040    10203040</code></pre><h2 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>stack是体现栈的容器，先进后出，只能访问栈顶元素</p><p>即只有顶端元素才可以被外界使用，因此栈不允许有遍历行为</p><p>栈中进入数据push</p><p>栈中弹出数据pop</p><h3 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h3><p>构造函数：</p><ul><li><code>stack&lt;T&gt; stk;//默认构造函数</code></li><li><code>stack(const stack &amp;stk);//拷贝构造函数</code></li></ul><p>赋值操作：</p><ul><li><code>stack&amp; operator=(const stack &amp;stk);//重载等号操作符</code></li></ul><p>数据存取：</p><ul><li><code>push(elem);//从栈顶添加元素</code></li><li><code>pop();//从栈顶移除第一个元素</code></li><li><code>top();//返回栈顶元素</code></li></ul><p>大小操作：</p><ul><li><code>empty();//判空，栈空为1</code></li><li><code>size();//返回栈的大小</code></li></ul><pre class=" language-c++"><code class="language-c++">void test01()&#123;    stack<int> s;    s.push(10);    s.push(20);    s.push(30);    s.pop();    cout << s.top() << endl;    stack<int> s2;    s2 = s;    cout << s.top();&#125;</code></pre><h2 id="queue容器"><a href="#queue容器" class="headerlink" title="queue容器"></a>queue容器</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><p>即表示队列的数据结构，先进先出，有两个出口</p><p>允许从一端新增元素，从一端移除元素</p><p>只允许访问对头和队尾，因此不支持遍历整个队列</p><h3 id="常用接口-1"><a href="#常用接口-1" class="headerlink" title="常用接口"></a>常用接口</h3><p>构造函数：</p><ul><li><code>queue&lt;T&gt;que;//queue采用模板类实现，queue对象的默认构造函数</code></li><li><code>queue(const queue &amp;que);//拷贝构造函数</code></li></ul><p>赋值操作：</p><ul><li><code>queue&amp; operator=(const queue &amp;que);//重载等号操作符</code></li></ul><p>数据存取：</p><p>队尾进，队头出</p><ul><li><code>push(elem);//在队尾添加数据</code></li><li><code>pop();//在队头移除数据</code></li><li><code>back();//返回队尾元素</code></li><li><code>front();//返回队头元素</code></li></ul><p>大小操作：</p><ul><li><code>empty();//判空</code></li><li><code>size();//返回栈的大小</code></li></ul><pre class=" language-c++"><code class="language-c++">void test01()&#123;    queue<int> q;    q.push(10);        //10     q.push(20);        //20 10    q.push(30);        //30 20 10    q.push(40);        //40 30 20 10    if (!q.empty())    &#123;        q.pop();    //40 30 20    &#125;    cout << q.back() << endl;    cout << q.front() << endl;    queue<int> q2;    q2 = q;    cout << q2.size();&#125;=>     40    20    3</code></pre><h2 id="List容器"><a href="#List容器" class="headerlink" title="List容器"></a>List容器</h2><h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h3><p>list即表示链表的数据结构</p><p>是一种物理存储上非连续的存储结构，数据元素的逻辑关系通过指针链接来实现</p><p>链表由一系列结点组成</p><p>结点包括储存元素的数据域和存储指向下一个结点的指针(<strong>下一个结点的地址</strong>)</p><p>数据中，结点由结构体创建</p><p><strong>STL中的链表是一个双向循环链表</strong></p><p>List的存储空间并不是连续的物理存储空间，因此List的迭代器只支持前移和后移，是双向迭代器</p><p><u>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的</u></p><p><img src="C:\Users\张驰\AppData\Roaming\Typora\typora-user-images\image-20210301204815294.png" alt="image-20210301204815294"></p><h3 id="list构造函数"><a href="#list构造函数" class="headerlink" title="list构造函数"></a>list构造函数</h3><p>函数原型：</p><ul><li>list<T> lst;//list采用模板类实现，对象的默认构造形式</li><li>list(beg,end);//将[beg,end)区间内的元素拷贝到容器中</li><li>list(n,elem);//构造函数将n个elem拷贝到容器中</li><li>list(const list &amp;lst);//拷贝构造函数</li></ul><pre class=" language-c++"><code class="language-c++">void test01()&#123;    list<int> lst1;    lst1.push_back(20);    lst1.push_back(30);    lst1.push_front(10);    printl(lst1);    list<int> lst2(lst1.begin(), lst1.end());    printl(lst2);    list<int> lst3(2, 829);    printl(lst3);    list<int>lst4;    lst4 = lst3;    printl(lst3);&#125;=>    102030    102030    829829    829829</code></pre><h3 id="list赋值和交换"><a href="#list赋值和交换" class="headerlink" title="list赋值和交换"></a>list赋值和交换</h3><p>函数原型：</p><ul><li><code>assign(beg,end);</code></li><li><code>assign(n,elem);</code></li><li><code>list&amp; operator=(const list &amp;lst);</code></li><li><code>swap(lst);//将lst与本身的元素互换</code></li></ul><pre class=" language-c++"><code class="language-c++">//交换void test02()&#123;    list<int> lst1;    lst1.push_back(20);    lst1.push_back(30);    lst1.push_front(10);    list<int> lst2(2, 829);    cout << "交换前：" << endl;    printl(lst1);     printl(lst2);     lst1.swap(lst2);    cout << "交换后：" << endl;    printl(lst1);    printl(lst2); &#125;=>    交换前：    102030    829829    交换后：    829829    102030</code></pre><h3 id="list大小操作"><a href="#list大小操作" class="headerlink" title="list大小操作"></a>list大小操作</h3><p>函数原型：</p><ul><li><code>size();//返回容器中元素个数</code></li><li><code>empty();//判断容器是否为空</code></li><li><code>resize(num);</code></li><li><code>resize(num,elem);</code></li></ul><h3 id="list插入和删除"><a href="#list插入和删除" class="headerlink" title="list插入和删除"></a>list插入和删除</h3><p>函数原型：</p><ul><li><code>push_back(elem);//在容器尾部添加一个元素</code></li><li><code>pop_back();//删除容器尾部的一个元素</code></li><li><code>push_front(elem);//在容器开头添加一个元素</code></li><li><code>pop_front();//删除容器开头的一个元素</code></li><li><code>insert(pos,elem);//在pos位置**插入elem元素的拷贝**，返回新数据的位置</code></li><li><code>insert(pos,beg,end);//在pos位置插入区间[beg,end)内的数据，无返回值</code></li><li><code>clear();//清除容器中所有元素</code></li><li><code>erase(pos);//删除pos位置的元素，返回下一个元素的位置</code></li><li><code>erase(beg,end);//删除[beg,end)区间中的元素，返回下一个元素的位置</code></li><li><code>**remove(elem);//移除容器中和elem值匹配的元素**</code></li></ul><h3 id="list数据存取"><a href="#list数据存取" class="headerlink" title="list数据存取"></a>list数据存取</h3><p>list不支持at访问和[]访问</p><p>因为list的迭代器是双向迭代器，不支持随机访问</p><p>函数原型：</p><ul><li>front();//返回第一个元素</li><li>back();//返回最后一个元素</li></ul><pre class=" language-c++"><code class="language-c++">//list容器的迭代器是双向迭代器，不支持随机访问list<int>::iterator it =L1.begin();//it=it+1;//错误，不可以跳跃访问，即使是+1</code></pre><h3 id="list反转和排序"><a href="#list反转和排序" class="headerlink" title="list反转和排序"></a>list反转和排序</h3><p>将容器中的元素反转，将容器中的数据排序</p><p>函数原型：</p><ul><li><code>reverse();//反转链表</code></li><li><code>sort();//链表排序</code></li></ul><pre class=" language-c++"><code class="language-c++">bool myCompare(int val1,int val2)&#123;    return val1 > val2;&#125;void test03()&#123;    list<int> lst1;    lst1.push_back(20);    lst1.push_back(30);    lst1.push_front(10);    //sort(lst1.begin(),lst1.end());    //无法使用这种随机迭代器访问的方式访问list    lst1.sort();    printl(lst1);    lst1.sort(myCompare);    printl(lst1);&#125;//默认排序方式是从小到大//对于自定义数据类型，必须要指定排序规则=>    102030    302010</code></pre><pre class=" language-c++"><code class="language-c++">bool compare(Person& p1, Person& p2)&#123;    if (p1.m_age == p2.m_age)        return p1.m_height > p2.m_height;    else        return p1.m_age < p2.m_age;&#125;//高级排序只是在排序规则上再进行一次逻辑规则制定</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;STL常用容器2&lt;/p&gt;
&lt;p&gt;STL是低阶码农的归宿。—《不知名弹幕》&lt;/p&gt;
&lt;p&gt;推荐赫斌老师的数据结构。  —《某不知名弹幕》&lt;/p&gt;
&lt;p&gt;STL中List和vector是两个最常被使用的容器&lt;/p&gt;
&lt;h2 id=&quot;vector容器&quot;&gt;&lt;a href=&quot;#vec</summary>
      
    
    
    
    
    <category term="数据结构" scheme="https://1doctorc1.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>STL与容器</title>
    <link href="https://1doctorc1.github.io/2021/03/04/stl-yu-rong-qi/"/>
    <id>https://1doctorc1.github.io/2021/03/04/stl-yu-rong-qi/</id>
    <published>2021-03-04T09:49:03.000Z</published>
    <updated>2021-03-04T09:49:41.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="STL与容器"><a href="#STL与容器" class="headerlink" title="STL与容器"></a>STL与容器</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>STL(standard template library)标准模板库</p><p>容器container</p><p>算法algorithm</p><p>迭代器iterator</p><p>容器：各种数据结构，用于存放数据，如：vector,list,deque,set,map</p><p>​    STL容器就是将最常用的数据结构实现出来</p><p>​    最常用的数据结构：数组，链表，树，图，队列，集合</p><p>算法：操作容器，如：sort，find，copy，for_each</p><p>迭代器：提供一种方法，使之能遍历容器中所有的元素，而又不暴露元素内部的方法</p><p>​    类似于指针</p><h3 id="容器算法迭代器初识"><a href="#容器算法迭代器初识" class="headerlink" title="容器算法迭代器初识"></a>容器算法迭代器初识</h3><h4 id="vector存放内置数据类型"><a href="#vector存放内置数据类型" class="headerlink" title="vector存放内置数据类型"></a>vector存放内置数据类型</h4><p>容器：vector</p><p>算法：for_each</p><p>迭代器：vector&lt;int,&gt;iterator</p><pre class=" language-c++"><code class="language-c++">void print(int val)&#123;    cout << val << endl;&#125;void test01()&#123;    vector<int> v;    v.push_back(10);    v.push_back(20);    v.push_back(30);    v.push_back(40);    vector<int>::iterator begin = v.begin();    vector<int>::iterator end = v.end();    /*    * while (begin != end)    &#123;        cout << *begin << endl;        begin++;    &#125;    */    for_each(begin, end, print);&#125;</code></pre><h4 id="vector存放自定义数据类型"><a href="#vector存放自定义数据类型" class="headerlink" title="vector存放自定义数据类型"></a>vector存放自定义数据类型</h4><pre class=" language-c++"><code class="language-c++">#include<vector>using namespace std;#include<string>class person &#123;public:    string m_name;    int m_age;public:    person(string name, int age)    &#123;        this->m_name = name;        this->m_age = age;    &#125;&#125;;void test01()&#123;    vector<person> p;    person p1("aaa", 0);    person p2("bbb", 3);    p.push_back(p1);    p.push_back(p2);    for (vector<person>::iterator it = p.begin(); it != p.end(); it++)    &#123;        cout << "name:" << (*it).m_name << endl << "age:" << (*it).m_age << endl;    &#125;&#125;void test02()&#123;    vector<person*> p;  //参数列表中为person*    person p1("aaa", 0);    person p2("bbb", 3);    p.push_back(&p1);    p.push_back(&p2);    for (vector<person*>::iterator it = p.begin(); it != p.end(); it++)    &#123;        person* p = (*it);  //it为一个指向指针的指针，it解引用是一个指针赋给p        cout << "name:" << p->m_name << endl << "age:" << p->m_age << endl;    &#125;&#125;</code></pre><p><strong><u>vector容器嵌套容器</u></strong></p><h3 id="STL常用容器"><a href="#STL常用容器" class="headerlink" title="STL常用容器"></a>STL常用容器</h3><h4 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h4><h5 id="string类构造"><a href="#string类构造" class="headerlink" title="string类构造"></a>string类构造</h5><ul><li><code>string();</code>        </li><li><code>string(const char*s);</code></li><li><code>string(const string&amp;str);</code></li><li><code>string(int n,char c);</code></li></ul><pre class=" language-c++"><code class="language-c++">void test01()&#123;    //string字符串的4种构造方式    string str1;//空字符串    cout << str1 << endl;    const char* s = "hello";    string str2 = s;        //字符数组    cout << str2 << endl;    const string str = "world";    string str3 = str;        //同类stirng类对象    cout << str3 << endl;    string str4 = string(10, 'a');        //相同数量的字符    cout << str4 << endl;&#125;/*=>helloworldaaaaaaaaaa*/</code></pre><h5 id="string赋值操作"><a href="#string赋值操作" class="headerlink" title="string赋值操作"></a>string赋值操作</h5><p>注意一些方法不能用于初始化，但是可以用于赋值</p><ul><li><code>string&amp; operator=(const char*s);</code></li><li><code>string&amp; operator=(const string &amp;str);</code></li><li><code>string&amp;operator=(char c);</code></li><li><code>string&amp; assign(const char*s);</code></li><li><code>string&amp;assign(const char*s ,int n);</code></li><li><code>string&amp;assign(const string &amp;s);</code></li><li><code>string&amp;assign(int n,char c);</code></li></ul><pre class=" language-c++"><code class="language-c++">void test01()&#123;    string str1 = "hell";    //用字符串赋值    string str2 = str1;        //同类对象赋值    //string str3 = 'o';    string str3;    str3 = 'o';                //可以使用字符赋值，但不可用字符初始化    //string str4.assign("wor"); //同上    string str4;    str4.assign("wor");    string str5;    str5.assign(str4);&#125;</code></pre><p>assign不是很常用的方法，用作了解</p><h5 id="string拼接"><a href="#string拼接" class="headerlink" title="string拼接"></a>string拼接</h5><pre class=" language-c++"><code class="language-c++">void test01()&#123;    string str1 = "i ";    str1 += "love ";    string str2 = "game";    str1 += str2;    str1 += ':';    cout << str1;&#125;=> i love game:</code></pre><pre class=" language-c++"><code class="language-c++">void test02()&#123;    string str1;    str1 = 'i';    str1.append(" love");    str1.append(" game abcde", 5);        //从开始读取5个字符    str1.append("dnf lol wzry", 3, 4);    //从下标3开始读取4个字符    cout << str1;&#125;=> i love game lol</code></pre><h5 id="string查找与替换"><a href="#string查找与替换" class="headerlink" title="string查找与替换"></a>string查找与替换</h5><p>函数原型：</p><ul><li><code>int find(const char *s,int pos=0) const;</code>查找字符串出现的位置，从pos开始查找</li><li><code>int rfind(const char*s,int pos=npos) const;</code>同上</li><li><code>string&amp; replace(int pos,int n,const char*s);</code>替换从pos开始的n个字符为字符串s</li></ul><pre class=" language-c++"><code class="language-c++">void test01()&#123;    string str = "abcdefgde";    int pos = str.find("de");    cout << "pos: " << pos << endl;    pos = str.rfind("de");    cout << "pos: " << pos << endl;&#125;//find查找从左往右，rfind从右往左//find找到字符串后返回查找的第一个字符位置，找不到返回-1=>    pos: 3    pos: 7</code></pre><pre class=" language-c++"><code class="language-c++">void test02()&#123;    string str = "1234567";    str.replace(2, 3, "11111");    cout << str;&#125;//replace在替换时，要指定从哪个位置起，多少个字符，替换成什么=>     121111167</code></pre><h5 id="string字符比较"><a href="#string字符比较" class="headerlink" title="string字符比较"></a>string字符比较</h5><p>函数原型：</p><ul><li><code>int compare(const char *s) const</code></li></ul><pre class=" language-c++"><code class="language-c++">void test03()&#123;    string str1 = "hello";    string str2 = "hello ";    int ret = str1.compare(str2);    if (ret == 0)    &#123;        cout << "str1=str2";    &#125;    else        cout << "str1!=str2";&#125;//等于返回0//大于返回1//小于返回-1=>     str1!=str2</code></pre><p>字符串比较主要用于判断两个字符串是否相等</p><h5 id="string字符串存取"><a href="#string字符串存取" class="headerlink" title="string字符串存取"></a>string字符串存取</h5><p>函数原型：</p><ul><li><code>char&amp; operator[](int n);</code></li><li><code>char&amp; at(int n);</code></li></ul><pre class=" language-c++"><code class="language-c++">void test04()&#123;    string str = "hello world";    str[3] = 'x';    for (int i = 0; i < str.size(); i++)        cout << str[i];    cout << endl;    str.at(5) = 'x';    for (int i = 0; i < str.size(); i++)        cout << str.at(i);    cout << endl;&#125;=>     helxo world    helxoxworld</code></pre><h5 id="string插入和删除"><a href="#string插入和删除" class="headerlink" title="string插入和删除"></a>string插入和删除</h5><p>函数原型：</p><ul><li><code>string&amp; insert(int pos ,const char*s);</code></li><li><code>string&amp; erase(int pos,int n=npos);</code></li></ul><pre class=" language-c++"><code class="language-c++">void test05()&#123;    string str;    str = "hello world";    str.insert(5, "   ");  //插入位置，插入字符    cout << str << endl;    str.erase(2, 5);         //从2号位置开始5个字符    cout << str << endl;&#125;//插入和删除的起始下标都是从0开始的=>     hello    world    he   world</code></pre><h5 id="string子串"><a href="#string子串" class="headerlink" title="string子串"></a>string子串</h5><p>函数原型：</p><ul><li><code>string sbustr(int pos=0,int n=npos) const;</code></li></ul><pre class=" language-c++"><code class="language-c++">void test06()&#123;    string str = "abcd";    string str1 = str.substr(0, 2);    cout << str1 << endl;    string str2 = "228178@qq.com";    int pos = str2.find("@");    string str3 = str2.substr(0, pos);    cout << str3;&#125;=>    ab    228178</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;STL与容器&quot;&gt;&lt;a href=&quot;#STL与容器&quot; class=&quot;headerlink&quot; title=&quot;STL与容器&quot;&gt;&lt;/a&gt;STL与容器&lt;/h2&gt;&lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基</summary>
      
    
    
    
    
    <category term="数据结构" scheme="https://1doctorc1.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>python</title>
    <link href="https://1doctorc1.github.io/2021/02/05/python/"/>
    <id>https://1doctorc1.github.io/2021/02/05/python/</id>
    <published>2021-02-05T01:03:13.000Z</published>
    <updated>2021-02-05T01:03:45.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pycharm安装、配置和使用指南"><a href="#pycharm安装、配置和使用指南" class="headerlink" title="pycharm安装、配置和使用指南"></a>pycharm安装、配置和使用指南</h1><p>terminal：终端</p><p>administrator：管理员用户</p><p>new scratch file:创建新的暂存文件</p><p>plugin:插件</p><p>External Libraries:外部库</p><p><u><strong>pycharm运行py文件快捷键：ctrl+shift+F10</strong></u></p><p>setting</p><pre class=" language-python"><code class="language-python"><span class="token triple-quoted-string string">"""作者：$&amp;#123;USER&amp;#125;日期：$&amp;#123;YEAR&amp;#125;年$&amp;#123;MONTH&amp;#125;月$&amp;#123;DAY&amp;#125;日"""</span><span class="token comment" spellcheck="true">#""""""指字符串</span><span class="token comment" spellcheck="true">#$(美元符)+&amp;#123;&amp;#125;指变量</span></code></pre><h1 id="python基础知识学习"><a href="#python基础知识学习" class="headerlink" title="python基础知识学习"></a>python基础知识学习</h1><h2 id="1-原始数据类型和运算符"><a href="#1-原始数据类型和运算符" class="headerlink" title="1.  原始数据类型和运算符"></a>1.  原始数据类型和运算符</h2><ol><li>除法：自动转为浮点数</li></ol><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">35</span><span class="token operator">/</span><span class="token number">5</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># => 7.0</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">36</span><span class="token operator">/</span><span class="token number">5</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># => 7.2</span></code></pre><ol start="2"><li>整数除法(//)：结果向下取整</li></ol><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">35</span><span class="token operator">//</span><span class="token number">5</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => 7</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">36</span><span class="token operator">//</span><span class="token number">5</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => 7</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">36.0</span><span class="token operator">//</span><span class="token number">5.0</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => 7.0</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => -2</span></code></pre><ol start="3"><li><p>x的y次方：2**4=16</p></li><li><p>用not给布尔值取非：</p></li></ol><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token operator">not</span> <span class="token boolean">True</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># => False</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token operator">not</span> <span class="token boolean">False</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => True</span><span class="token comment" spellcheck="true">#print(not TRUE)    #报错，True和False严格区分大小写</span></code></pre><ol start="5"><li>逻辑运算符and和or(与和或)，and和or均为小写，严格区分大小写</li></ol><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token boolean">True</span> <span class="token operator">and</span> <span class="token boolean">False</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => False</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token boolean">False</span> <span class="token operator">or</span> <span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => True</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token boolean">True</span> <span class="token operator">and</span> <span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => True</span></code></pre><ol start="6"><li>大小比较连起来</li></ol><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">></span><span class="token number">3</span><span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => False</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">&lt;</span><span class="token number">4</span><span class="token operator">></span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => True</span><span class="token comment" spellcheck="true">#并不是逐个比较，即2>3得False(0),0&lt;1结果应为True</span><span class="token comment" spellcheck="true">#而是同时对左右进行比较：3&lt;4为True，4>1为True，所以结果为True</span></code></pre><ol start="7"><li>字符串可以用单引号或者双引号</li></ol><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'i am 字符串'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"i am 字符串"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#两种方法都可以，一般情况下使用双引号</span></code></pre><ol start="8"><li>用加号连接字符串，类似于java</li></ol><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello "</span><span class="token operator">+</span><span class="token string">"python"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => hello python</span></code></pre><ol start="9"><li><strong>字符串可以当作字符数组来访问数组元素</strong></li></ol><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"this is a new problem"</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => i</span><span class="token comment" spellcheck="true">#print("this is a new problem"[2][3][5]) #输出结果并不为isi，报错信息为string index out of range，推测可能被当作多维数组</span><span class="token comment" spellcheck="true">#以下情况倒是可以</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"this"</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">"is"</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">"my"</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => iim</span></code></pre><p>10.<strong><u>用.format来格式化字符串</u></strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&amp;#123;&amp;#125; can be &amp;#123;&amp;#125;"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">"strings"</span><span class="token punctuation">,</span><span class="token string">"interpolated"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    # <span class="token operator">=</span><span class="token operator">></span> strings can be interpolated<span class="token comment" spellcheck="true">#interpolated:插入，以内插值替换的</span><span class="token comment" spellcheck="true">#格式：   "字符串&amp;#123;待格式化内容&amp;#125;".format("格式化内容")</span><span class="token comment" spellcheck="true">#不加控制符号为逐个替换</span></code></pre><ol start="11"><li><p>可以使用重复参数节省时间(添加控制符)</p><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&amp;#123;0&amp;#125; is a real foolguys , but &amp;#123;0&amp;#125; is pretty funny , &amp;#123;1&amp;#125; ,oh i don't konw"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># => a is a real foolguys , but a is pretty funny , b ,oh i don't konw</span><span class="token comment" spellcheck="true">#&amp;#123;0&amp;#125;被替换成format的第一个字符串参数</span><span class="token comment" spellcheck="true">#&amp;#123;1&amp;#125;被替换为format的第二个字符串参数</span></code></pre></li><li><p>也可以用类似于微信小程序的关键字数据绑定</p></li></ol><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&amp;#123;name&amp;#125; just want to say it's too long"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"i"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># => i just want to say it's too long</span><span class="token comment" spellcheck="true">#老式格式化语法类似于C中的scanf，仅作了解</span></code></pre><ol start="13"><li><p>None</p><p>None是一个对象</p></li></ol><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#print(none)        #此语句将导致后面无法输出</span><span class="token keyword">print</span><span class="token punctuation">(</span>None<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># =>None</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"etc"</span> <span class="token keyword">is</span> None<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#False</span><span class="token keyword">print</span><span class="token punctuation">(</span>None <span class="token keyword">is</span> None<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#True</span></code></pre><ol start="14"><li>特殊的布尔判断</li></ol><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>bool<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#False</span><span class="token keyword">print</span><span class="token punctuation">(</span>bool<span class="token punctuation">(</span>None<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#False</span><span class="token keyword">print</span><span class="token punctuation">(</span>bool<span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;&amp;#125;))        #False    空列表</span><span class="token keyword">print</span><span class="token punctuation">(</span>bool<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#False    空字典？</span><span class="token comment" spellcheck="true">#所有其他值都是True</span></code></pre><h2 id="2-变量和集合"><a href="#2-变量和集合" class="headerlink" title="2.变量和集合"></a>2.变量和集合</h2><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ol><li>在给变量赋值前不用提前声明</li><li>用列表(list)储存序列</li></ol><pre class=" language-python"><code class="language-python">li<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">#创建列表</span><span class="token keyword">print</span><span class="token punctuation">(</span>li<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => 1   ##像访问数组一样访问列表元素</span></code></pre><ol start="3"><li>用append在列表最后追加元素/用pop从列表尾部删除/直接取出列表最后一个元素</li></ol><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#续上</span>li<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#此时li列表元素为[1,2,4,5],即自动在末尾加</span><span class="token keyword">print</span><span class="token punctuation">(</span>li<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#可以直接访问这个新加入的元素</span>li<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#中间没有参数是直接删除最后一个，此时li列表元素为[1,2,4]</span><span class="token comment" spellcheck="true">#print(li[3])    #报错：list index out of range</span><span class="token keyword">print</span><span class="token punctuation">(</span>li<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#无论列表长度为多少，直接取出最后一个元素</span></code></pre><h3 id="列表的切割语法"><a href="#列表的切割语法" class="headerlink" title="列表的切割语法"></a>列表的切割语法</h3><p>可以用三个参数的任何组合来构成切割：list[始：终：步伐]</p><p>步伐省略默认为1，即逐个访问</p><p>两种理解方式：</p><p>0-1存储第一个元素，1-2存储第二个元素</p><p>始终按数组形式从0开始，这种方式不访问终坐标的元素</p><pre class=" language-python"><code class="language-python">li<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>li<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => [1]    #注意输出的元素带[]</span><span class="token keyword">print</span><span class="token punctuation">(</span>li<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => [4]</span><span class="token keyword">print</span><span class="token punctuation">(</span>li<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => [2,4]</span><span class="token comment" spellcheck="true">#取尾</span><span class="token keyword">print</span><span class="token punctuation">(</span>li<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => [1,2]</span><span class="token keyword">print</span><span class="token punctuation">(</span>li<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => [1,2]</span><span class="token comment" spellcheck="true">#取头</span><span class="token keyword">print</span><span class="token punctuation">(</span>li<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => [4,3]</span><span class="token keyword">print</span><span class="token punctuation">(</span>li<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => [4,3]</span><span class="token comment" spellcheck="true">#逐个取/隔一个取一个</span><span class="token keyword">print</span><span class="token punctuation">(</span>li<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#[1,2,4,3]</span><span class="token keyword">print</span><span class="token punctuation">(</span>li<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#[1,4]</span><span class="token comment" spellcheck="true">#倒序取</span><span class="token keyword">print</span><span class="token punctuation">(</span>li<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#[3,4,2,1]</span></code></pre><h3 id="列表2"><a href="#列表2" class="headerlink" title="列表2"></a>列表2</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#用del删除任何一个元素</span>list<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">#定义并初始化列表</span><span class="token keyword">del</span> list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">#用del删除任何一个元素</span><span class="token keyword">del</span> list<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">#用del删除最后一个元素</span><span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#[2,4]</span>                <span class="token comment" spellcheck="true">#不像C++不能直接输出非字符数组</span><span class="token comment" spellcheck="true">#列表可以相加，并且相加的原列表值不变</span><span class="token comment" spellcheck="true">#续上</span>list2<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token operator">+</span>list2<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># => [2,4,6,5,7]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">(</span>list<span class="token operator">+</span>list2<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => 4                #访问拼接后的单个元素</span><span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># => [2,4]</span><span class="token keyword">print</span><span class="token punctuation">(</span>list2<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># => [6,5,7]</span><span class="token comment" spellcheck="true">#用extend拼接列表</span>list<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>list2<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># =>[2,4,6,5,7]</span><span class="token comment" spellcheck="true">#用in测试列表是否包含某个值 格式：要测试是否包含的值+in+列表名</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">in</span> list<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => False    #list中并没有1</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token keyword">in</span> list<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => True    #list中有2</span><span class="token comment" spellcheck="true">#用len获取列表长度</span><span class="token keyword">print</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => 5 </span></code></pre><h3 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组(tuple)"></a>元组(tuple)</h3><p>元组是不可改变的序列</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#元组特殊的地方</span>tup1<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#用括号初始化和定义</span><span class="token keyword">print</span><span class="token punctuation">(</span>tup1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># => 2    像列表一样用[]访问元素</span><span class="token comment" spellcheck="true">#tup1[2]=4            #    尝试修改元组元素，报错：'tuple' object does not support item assignment(元组对象不支持项目分配)</span><span class="token keyword">print</span><span class="token punctuation">(</span>tup1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># => 3</span><span class="token comment" spellcheck="true">#元组可以进行大部分列表的操作</span><span class="token comment" spellcheck="true">#tup1.append(1)        #报错：'tuple' object has no attribute 'append'，tuple对象没有append属性，同理没有pop()</span><span class="token comment" spellcheck="true">#取出最后一个元素</span><span class="token keyword">print</span><span class="token punctuation">(</span>tup1<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># => 3</span><span class="token comment" spellcheck="true">#切割取法(注意有点不一样)</span><span class="token keyword">print</span><span class="token punctuation">(</span>tup1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => (2,)</span><span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => [4]</span><span class="token keyword">print</span><span class="token punctuation">(</span>tup1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => (1,2)</span><span class="token keyword">print</span><span class="token punctuation">(</span>tup1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># => (1,2,3)</span><span class="token comment" spellcheck="true">#相加/拼接/包含/取长度</span><span class="token keyword">print</span><span class="token punctuation">(</span>tup1<span class="token operator">+</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => (1,2,3,3,5,6)</span>tup1<span class="token operator">+</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#元组无法改变，包括拼接，只能通过拼接改变输出</span><span class="token keyword">print</span><span class="token punctuation">(</span>tup1<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># => (1,2,3)</span><span class="token keyword">print</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>tup1<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => (3)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">4</span> <span class="token keyword">in</span> tup1<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => False</span><span class="token comment" spellcheck="true">#元组特殊的地方</span><span class="token comment" spellcheck="true">#可以把元组和列表解包，赋给变量</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => 1 2 3</span>d<span class="token punctuation">,</span>e<span class="token punctuation">,</span>f<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span>e<span class="token punctuation">,</span>f<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => 4 5 6</span><span class="token comment" spellcheck="true">#print中逗号，被当作分隔符，输出的数字被转为中间为空格</span><span class="token comment" spellcheck="true">#元组周围的括号可以省略</span>d<span class="token punctuation">,</span>e<span class="token punctuation">,</span>f<span class="token operator">=</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span>e<span class="token punctuation">,</span>f<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => 7 8 9</span><span class="token comment" spellcheck="true">#！！！</span><span class="token comment" spellcheck="true">#交换两个变量的值</span>a<span class="token operator">=</span>bb<span class="token operator">=</span>a<span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># => 2 2</span><span class="token comment" spellcheck="true">#同时进行改变，不需要中间变量</span>d<span class="token punctuation">,</span>e<span class="token operator">=</span>e<span class="token punctuation">,</span>d<span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span>e<span class="token punctuation">,</span>f<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => 8 7 9</span><span class="token comment" spellcheck="true">#！！！</span></code></pre><h3 id="字典-dict-dictionary"><a href="#字典-dict-dictionary" class="headerlink" title="字典(dict)dictionary"></a>字典(dict)dictionary</h3><p>特别注意：keys和列表的结合</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#空字典</span>empty_dict<span class="token operator">=</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;&amp;#125;</span><span class="token comment" spellcheck="true">#初始化字典</span><span class="token comment" spellcheck="true">#filled_dict=&amp;#123;"one"=1,"two"=2,"three"=3&amp;#125;    #报错：invalid syntax 无效语法</span><span class="token comment" spellcheck="true">#正确的赋值方式是“键值对”的形式</span>filled_dict<span class="token operator">=</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;"one":1,"two":2,"three":3&amp;#125;</span><span class="token keyword">print</span><span class="token punctuation">(</span>filled_dict<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># => &amp;#123;'one': 1, 'two': 2, 'three': 3&amp;#125;</span><span class="token comment" spellcheck="true">#访问字典元素</span><span class="token comment" spellcheck="true">#print(filled_dict[1])        #报错：keyerror</span><span class="token keyword">print</span><span class="token punctuation">(</span>filled_dict<span class="token punctuation">[</span><span class="token string">"one"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => 1</span><span class="token comment" spellcheck="true">#字典中的keys</span><span class="token comment" spellcheck="true">#用keys获得字典中所有的键(没有值)</span>another_dictionary<span class="token operator">=</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;"four":4&amp;#125;        </span><span class="token keyword">print</span><span class="token punctuation">(</span>another_dictionary<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => dict_keys(["four"])</span><span class="token keyword">print</span><span class="token punctuation">(</span>filled_dict<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># => dict_keys(["one","two","three"])</span><span class="token comment" spellcheck="true">#用keys返回一个“可迭代”的对象，所以可以把结果放在一个list中</span>filled_dict<span class="token operator">=</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;"one":1,"two":2,"three":3&amp;#125;</span><span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">(</span>filled_dict<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># => ["one","two","three"]</span><span class="token comment" spellcheck="true">#用values获得所有的值(没有键)</span><span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">(</span>filled_dict<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># => [1,2,3]</span><span class="token comment" spellcheck="true">#用in测试一个字典中是否包含某个键</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"one"</span> <span class="token keyword">in</span> filled_dict<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># => True</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">in</span> filled_dict<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># => False</span><span class="token comment" spellcheck="true">#仅能判断键，所有的值都会判断为False</span><span class="token comment" spellcheck="true">#回顾字典访问元素的方式</span><span class="token keyword">print</span><span class="token punctuation">(</span>filled_dict<span class="token punctuation">[</span><span class="token string">"one"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => 1</span></code></pre><h3 id="字典2"><a href="#字典2" class="headerlink" title="字典2"></a>字典2</h3><ol><li>访问不存在的键</li></ol><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>filled_dict<span class="token punctuation">[</span><span class="token string">"four"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#报错：keyerror</span></code></pre><ol start="2"><li>用get访问字典元素,可以避免keyerror</li></ol><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>filled_dict<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => 1</span><span class="token keyword">print</span><span class="token punctuation">(</span>filled_dict<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"four"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => None，返回空对象</span></code></pre><ol start="3"><li>带两个参数的get访问</li></ol><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>filled_dict<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># => 1</span><span class="token comment" spellcheck="true">#字典中存在访问可访问的的键，则返回其对应的值</span><span class="token keyword">print</span><span class="token punctuation">(</span>filled_dict<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"four"</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => 5</span><span class="token comment" spellcheck="true">#字典中不存在可访问的键，将第二个参数作为默认值输出</span></code></pre><ol start="4"><li>用setdefault在只有当键不存在的时候插入新值</li></ol><pre class=" language-python"><code class="language-python">other_dict<span class="token punctuation">.</span>setdefault<span class="token punctuation">(</span><span class="token string">"sun"</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span>        other_dict<span class="token punctuation">.</span>setdefault<span class="token punctuation">(</span><span class="token string">"sun"</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>other_dict<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"sun"</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># => 7</span><span class="token keyword">print</span><span class="token punctuation">(</span>other_dict<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => dict_keys(['mon', 'tue', 'wedn', 'sun'])</span><span class="token comment" spellcheck="true">#1.只有第一次设置才有效</span><span class="token comment" spellcheck="true">#2.会将这个键值对插入到字典里</span></code></pre><ol start="5"><li>用del删除键值对</li></ol><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#other_dict.del("mon")报错</span><span class="token comment" spellcheck="true">#del other_dict("mon")报错</span><span class="token keyword">del</span> other_dict<span class="token punctuation">[</span><span class="token string">"mon"</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>other_dict<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># => &amp;#123;'tue': 2, 'wedn': 3, 'sun': 7&amp;#125;</span></code></pre><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ol><li>集合即数学意义上的数的集合，包括其特点</li></ol><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#集合基础</span>empty_set<span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">#用set表达集合</span>some_set<span class="token operator">=</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;1,1,2,3,4,4&amp;#125;    #集合的初始化方法</span>var_set<span class="token operator">=</span>some_set        <span class="token comment" spellcheck="true">#把集合作为一个整体赋给变量</span><span class="token keyword">print</span><span class="token punctuation">(</span>some_set<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># => &amp;#123;1,2,3,4&amp;#125;</span><span class="token keyword">print</span><span class="token punctuation">(</span>empty_set<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># => set()</span><span class="token keyword">print</span><span class="token punctuation">(</span>var_set<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># => &amp;#123;1,2,3,4&amp;#125;</span><span class="token comment" spellcheck="true">#集合运算</span><span class="token comment" spellcheck="true">#&amp;取交集</span><span class="token comment" spellcheck="true">#|取并集</span><span class="token comment" spellcheck="true">##-取补集##</span>other_set<span class="token operator">=</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;2,4,5&amp;#125;</span><span class="token keyword">print</span><span class="token punctuation">(</span>some_set<span class="token operator">&amp;</span>other_set<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># => &amp;#123;2,4&amp;#125;</span>third_set<span class="token operator">=</span>some_set<span class="token operator">|</span>other_set    <span class="token keyword">print</span><span class="token punctuation">(</span>third_set<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># => &amp;#123;1,2,3,4,5&amp;#125;</span><span class="token comment" spellcheck="true">#这里取补集是双目运算符，可以当成减</span><span class="token keyword">print</span><span class="token punctuation">(</span>some_set<span class="token operator">-</span>other_set<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># => &amp;#123;1,3&amp;#125;</span><span class="token comment" spellcheck="true">#集合包含in</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token keyword">in</span> some_set<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># => True</span></code></pre><h2 id="3-流程控制和迭代器"><a href="#3-流程控制和迭代器" class="headerlink" title="3. 流程控制和迭代器"></a>3. 流程控制和迭代器</h2><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#不需要加括号，但是注意缩进会影响代码</span><span class="token comment" spellcheck="true">#if、else、elif(else+if)后跟的语句要加冒号:</span><span class="token comment" spellcheck="true">#1</span>some_var<span class="token operator">=</span><span class="token number">5</span><span class="token keyword">if</span> some_var<span class="token operator">>=</span><span class="token number">10</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"some_var大于等于10"</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"some_var小于10"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># => some_var大于等于10</span><span class="token comment" spellcheck="true">#2</span><span class="token comment" spellcheck="true">#elif后记得加判断条件</span><span class="token keyword">if</span> some_var<span class="token operator">></span><span class="token number">10</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"some_var大于10"</span><span class="token punctuation">)</span><span class="token keyword">elif</span> some_var<span class="token operator">==</span><span class="token number">10</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"some_var等于10"</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"some_var小于10"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># => some_var小于10</span></code></pre><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#字符串循环</span><span class="token keyword">for</span> animal <span class="token keyword">in</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;"dog","cat","mouse"&amp;#125;:        #for 迭代的对象 in &amp;#123;&amp;#125;/[]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&amp;#123;&amp;#125; is a animal"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>animal<span class="token punctuation">)</span><span class="token punctuation">)</span>        #自动格式化，但是为什么自动从dog到mouse呢<span class="token triple-quoted-string string">""" =>dog is a animalcat is a animalmouse is a animal"""</span><span class="token comment" spellcheck="true">#数字循环    关键字range，返回数字列表从0到给的数字</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token triple-quoted-string string">"""自动换行0123"""</span></code></pre><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><pre class=" language-python"><code class="language-python">x<span class="token operator">=</span><span class="token number">0</span><span class="token keyword">while</span> x<span class="token operator">&lt;</span><span class="token number">4</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>    x<span class="token operator">+=</span><span class="token number">1</span><span class="token comment" spellcheck="true">#while冒号后的都处在while循环里</span><span class="token triple-quoted-string string">"""0123"""</span></code></pre><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>用try/except块处理异常情况</p><pre class=" language-python"><code class="language-python"></code></pre><h3 id="迭代与迭代器"><a href="#迭代与迭代器" class="headerlink" title="迭代与迭代器"></a>迭代与迭代器</h3><p><strong><u>Python提供一个叫做可迭代（iterable）的基本抽象。一个可迭代对象是可以被当作序列的对象。比如说上面range返回的对象就是可迭代的</u></strong></p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#my_iterable是一个实现可迭代接口的对象</span>filled_dict<span class="token operator">=</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;"one":1,"two":2,"three":3&amp;#125;</span>my_iterable<span class="token operator">=</span>filled_dict<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>my_iterable<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># => dict_keys(["one","two","three"])</span><span class="token comment" spellcheck="true">#可迭代对象可以遍历</span><span class="token keyword">for</span> i <span class="token keyword">in</span> my_iterable<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token triple-quoted-string string">"""onetwothree"""</span><span class="token comment" spellcheck="true">#但是可迭代对象不可以随机访问</span><span class="token comment" spellcheck="true">#print(my_iterable[1])，会导致后面的错误输出</span><span class="token comment" spellcheck="true">#可迭代对象与迭代器</span><span class="token comment" spellcheck="true">#可迭代对象生成迭代器，关键字iter</span>my_iterable<span class="token operator">=</span>iter<span class="token punctuation">(</span>my_iterable<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#迭代器是一个可以记住遍历位置的对象</span><span class="token keyword">print</span><span class="token punctuation">(</span>my_iterable<span class="token punctuation">.</span>__next__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => one</span><span class="token keyword">print</span><span class="token punctuation">(</span>my_iterable<span class="token punctuation">.</span>__next__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => two</span><span class="token keyword">print</span><span class="token punctuation">(</span>my_iterable<span class="token punctuation">.</span>__next__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => three </span><span class="token comment" spellcheck="true">#print(my_iterable.__next__())    # 抛出StopIteration</span><span class="token comment" spellcheck="true">#可以用list一次去除迭代器所有的元素</span><span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">(</span>filled_dict<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># => ['one', 'two', 'three']</span></code></pre><h2 id="4-函数"><a href="#4-函数" class="headerlink" title="4. 函数"></a>4. 函数</h2><h3 id="用def定义新函数"><a href="#用def定义新函数" class="headerlink" title="用def定义新函数"></a>用def定义新函数</h3><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">exchange</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"before change a=&amp;#123;&amp;#125;,b=&amp;#123;&amp;#125;"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"after change a=&amp;#123;&amp;#125;,b=&amp;#123;&amp;#125;"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>b<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> a<span class="token operator">+</span>bsum<span class="token operator">=</span>exchange<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token triple-quoted-string string">"""before change a=5,b=10after change a=10,b=515"""</span></code></pre><h3 id="用关键字参数调用函数"><a href="#用关键字参数调用函数" class="headerlink" title="用关键字参数调用函数"></a>用关键字参数调用函数</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#关键字参数可以用任意顺序</span><span class="token keyword">def</span> <span class="token function">exchange</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"before change a=&amp;#123;&amp;#125;,b=&amp;#123;&amp;#125;"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"after change a=&amp;#123;&amp;#125;,b=&amp;#123;&amp;#125;"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>b<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> anew_a<span class="token operator">=</span>exchange<span class="token punctuation">(</span>b<span class="token operator">=</span><span class="token number">13</span><span class="token punctuation">,</span>a<span class="token operator">=</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>new_a<span class="token punctuation">)</span><span class="token triple-quoted-string string">"""before change a=7,b=13after change a=13,b=77"""</span></code></pre><h3 id="形参与实参！！！区别于C"><a href="#形参与实参！！！区别于C" class="headerlink" title="形参与实参！！！区别于C++"></a>形参与实参！！！区别于C++</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">changevalues</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>    a<span class="token punctuation">,</span>b<span class="token operator">=</span>b<span class="token punctuation">,</span>a    <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>    <span class="token keyword">return</span> anew_a<span class="token operator">=</span>changevalues<span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>new_a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#形参可以影响实参</span><span class="token triple-quoted-string string">"""11 77 117"""</span></code></pre><h3 id="可变参数函数与关键字可变参数函数"><a href="#可变参数函数与关键字可变参数函数" class="headerlink" title="可变参数函数与关键字可变参数函数"></a>可变参数函数与关键字可变参数函数</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#*args,args是参数，那么*是代表可变参数吗？</span><span class="token comment" spellcheck="true">#(1,2,3)是一个元组，作为参数传递</span><span class="token keyword">def</span> <span class="token function">varargs</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> args<span class="token keyword">print</span><span class="token punctuation">(</span>varargs<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># => (1, 2, 3)</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#args和kwargs某种程度上是固定的</span><span class="token comment" spellcheck="true">#kwargs并不是某种类型的变量，只是关键字对应</span><span class="token keyword">def</span> <span class="token function">keyword_args</span><span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> kwargs<span class="token keyword">print</span><span class="token punctuation">(</span>keyword_args<span class="token punctuation">(</span>big<span class="token operator">=</span><span class="token string">"foot"</span><span class="token punctuation">,</span>loch<span class="token operator">=</span><span class="token string">"ness"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># => &amp;#123;'big': 'foot', 'loch': 'ness'&amp;#125;</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#两种可变参数同时作为函数参数</span><span class="token keyword">def</span> <span class="token function">all_the_args</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>kwargs<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>all_the_args<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">"""(1, 2)&amp;#123;'a': 3, 'b': 4&amp;#125;None"""</span></code></pre><p>*<em><u>调用可变参数函数时可以做跟上面相反的，用</em>展开序列，用两个展开字典</u>**</p><p>推测类似于C++地址传递中传递指针与传递对象的区别</p><p>为什么和上面的关键字可变函数不一样，这里是字典</p><pre class=" language-python"><code class="language-python">kwargs<span class="token operator">=</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;"one":1,"two":2,"five":5&amp;#125;</span><span class="token keyword">print</span><span class="token punctuation">(</span>all_the_args<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>all_the_args<span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>all_the_args<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">"""(1, 2, 3)&amp;#123;'one': 1, 'two': 2, 'five': 5&amp;#125;None"""</span><span class="token comment" spellcheck="true"># => 最后一句错误输出？</span></code></pre><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><pre class=" language-python"><code class="language-python">x<span class="token operator">=</span><span class="token number">5</span><span class="token keyword">def</span> <span class="token function">setX</span><span class="token punctuation">(</span>some_num<span class="token punctuation">)</span><span class="token punctuation">:</span>    x<span class="token operator">=</span>some_num    <span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">setglobalX</span><span class="token punctuation">(</span>other_num<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> x    <span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>    x<span class="token operator">=</span>other_num    <span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>setX<span class="token punctuation">(</span><span class="token number">43</span><span class="token punctuation">)</span>setglobalX<span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token triple-quoted-string string">"""4351313"""</span></code></pre><h3 id="函数的嵌套使用-分部传参"><a href="#函数的嵌套使用-分部传参" class="headerlink" title="函数的嵌套使用(分部传参)"></a>函数的嵌套使用(分部传参)</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">creat_adder</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">adder</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> x<span class="token operator">+</span>y    <span class="token keyword">return</span> adderadd_10<span class="token operator">=</span>creat_adder<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>add_10<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># => 13</span></code></pre><h3 id="匿名函数lambda"><a href="#匿名函数lambda" class="headerlink" title="匿名函数lambda"></a>匿名函数lambda</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span>x<span class="token operator">></span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => True</span></code></pre><h3 id="内置的高阶函数？？？"><a href="#内置的高阶函数？？？" class="headerlink" title="内置的高阶函数？？？"></a>内置的高阶函数？？？</h3><pre class=" language-python"><code class="language-python">map<span class="token punctuation">(</span>add_10<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># => [11, 12, 13]</span>filter<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x <span class="token operator">></span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># => [6, 7]</span></code></pre><h2 id="5-类"><a href="#5-类" class="headerlink" title="5.类"></a>5.类</h2><p>创建一个类合理的缩进形式</p><p><img src="C:\Users\张驰\AppData\Roaming\Typora\typora-user-images\image-20210203090308836.png" alt="image-20210203090308836"></p><h3 id="定义类和类属性"><a href="#定义类和类属性" class="headerlink" title="定义类和类属性"></a>定义类和类属性</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Human</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    species<span class="token operator">=</span><span class="token string">"H.sapiens"</span><span class="token comment" spellcheck="true">#类属性即可以被所有类的实例共用的属性</span></code></pre><h3 id="类实例的初始化-构造"><a href="#类实例的初始化-构造" class="headerlink" title="类实例的初始化(构造)"></a>类实例的初始化(构造)</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#定义方式，注意名字前后的双下划线</span><span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>    self<span class="token punctuation">.</span>name<span class="token operator">=</span>name</code></pre><h3 id="类实例的方法"><a href="#类实例的方法" class="headerlink" title="类实例的方法"></a>类实例的方法</h3><p>第一个参数总是self，就是这个实例对象？？？</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">say</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>msg<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token string">"&amp;#123;name&amp;#125;:&amp;#123;message&amp;#125;"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>name<span class="token operator">=</span>self<span class="token punctuation">.</span>name<span class="token punctuation">,</span>message<span class="token operator">=</span>msg<span class="token punctuation">)</span></code></pre><h3 id="类方法-成员函数？"><a href="#类方法-成员函数？" class="headerlink" title="类方法(成员函数？)"></a>类方法(成员函数？)</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#被此类实例共用，第一个参数是这个类对象</span>@classmethod<span class="token keyword">def</span> <span class="token function">get_species</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> cls<span class="token punctuation">.</span>species</code></pre><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>调用时没有实例或类的绑定</p><pre class=" language-python"><code class="language-python">@staticmethod<span class="token keyword">def</span> <span class="token function">grunt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token string">"grunt"</span></code></pre><p><strong>python的语法缩进影响构成</strong></p><h2 id="构造类的实例"><a href="#构造类的实例" class="headerlink" title="构造类的实例"></a>构造类的实例</h2><pre class=" language-python"><code class="language-python">i<span class="token operator">=</span>Human<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"Ian"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>say<span class="token punctuation">(</span><span class="token string">"hi"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>j<span class="token operator">=</span>Human<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"joel"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>j<span class="token punctuation">.</span>say<span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h2 id="调用一个类方法"><a href="#调用一个类方法" class="headerlink" title="调用一个类方法"></a>调用一个类方法</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>get_species<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h2 id="改一个共用的类属性"><a href="#改一个共用的类属性" class="headerlink" title="改一个共用的类属性"></a>改一个共用的类属性</h2><pre class=" language-python"><code class="language-python">Human<span class="token punctuation">.</span>species<span class="token operator">=</span><span class="token string">"H.neanderthalesis"</span><span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>get_species<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>j<span class="token punctuation">.</span>get_species<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h2 id="调用静态方法"><a href="#调用静态方法" class="headerlink" title="调用静态方法"></a>调用静态方法</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>Human<span class="token punctuation">.</span>grunt<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h1 id="6-模板"><a href="#6-模板" class="headerlink" title="6.模板"></a>6.模板</h1><h2 id="用import导入模板"><a href="#用import导入模板" class="headerlink" title="用import导入模板"></a>用import导入模板</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> math<span class="token keyword">print</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h2 id="也可以从模块中导入个别值"><a href="#也可以从模块中导入个别值" class="headerlink" title="也可以从模块中导入个别值"></a>也可以从模块中导入个别值</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> math <span class="token keyword">import</span> ceil<span class="token punctuation">,</span>floor<span class="token keyword">print</span><span class="token punctuation">(</span>ceil<span class="token punctuation">(</span><span class="token number">3.7</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># => 4</span><span class="token keyword">print</span><span class="token punctuation">(</span>floor<span class="token punctuation">(</span><span class="token number">3.7</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># => 3</span></code></pre><h2 id="可以导入一个模块中所有的值"><a href="#可以导入一个模块中所有的值" class="headerlink" title="可以导入一个模块中所有的值"></a>可以导入一个模块中所有的值</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> math <span class="token keyword">import</span> <span class="token operator">*</span></code></pre><h2 id="快捷使用模块-缩写模块名字"><a href="#快捷使用模块-缩写模块名字" class="headerlink" title="快捷使用模块(缩写模块名字)"></a>快捷使用模块(缩写模块名字)</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> math <span class="token keyword">as</span> m<span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token operator">==</span>math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h2 id="模块的实质"><a href="#模块的实质" class="headerlink" title="模块的实质"></a>模块的实质</h2><p>python模块其实就是普通的python文件，可以自己写，然后如上导入即可</p><p>模块的名字就是文件的名字</p><h2 id="列出模块中所有的值"><a href="#列出模块中所有的值" class="headerlink" title="列出模块中所有的值"></a>列出模块中所有的值</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> math<span class="token keyword">print</span><span class="token punctuation">(</span>dir<span class="token punctuation">(</span>math<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># => ['__doc__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'comb', 'copysign', 'cos', 'cosh', 'degrees', 'dist', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'isqrt', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nan', 'perm', 'pi', 'pow', 'prod', 'radians', 'remainder', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau', 'trunc']</span></code></pre><h1 id="7-高级用法"><a href="#7-高级用法" class="headerlink" title="7.高级用法"></a>7.高级用法</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pycharm安装、配置和使用指南&quot;&gt;&lt;a href=&quot;#pycharm安装、配置和使用指南&quot; class=&quot;headerlink&quot; title=&quot;pycharm安装、配置和使用指南&quot;&gt;&lt;/a&gt;pycharm安装、配置和使用指南&lt;/h1&gt;&lt;p&gt;terminal：终</summary>
      
    
    
    
    
    <category term="python" scheme="https://1doctorc1.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>C++期末复习</title>
    <link href="https://1doctorc1.github.io/2021/01/31/c-qi-mo-fu-xi/"/>
    <id>https://1doctorc1.github.io/2021/01/31/c-qi-mo-fu-xi/</id>
    <published>2021-01-31T03:55:31.000Z</published>
    <updated>2021-01-31T05:38:24.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-复习"><a href="#C-复习" class="headerlink" title="C++复习"></a>C++复习</h2><p>北京邮电大学期末复习考试资料</p><p>适用于北京邮电大学《C++程序设计语言》期末考试</p><ol><li><p>C基础</p><ol><li>面向过程的程序设计语言/结构化程序设计</li><li>结构化数据，结构化语句，数据抽象，过程抽象</li><li>面向<em>过程</em>的程序设计主要思想是<em>自顶向下</em>，逐步求精，模块化</li></ol></li><li><p>C++基础</p><ol><li>自底向上的分析，是从具体到抽象，因为oop(面向对象编程)的第一步是从对象抽象出类</li><li>自顶向下的分析，是从抽象到具体，从大概要处理数据的什么功能细致的规划每一个步骤</li><li>组成C++程序的是<strong>函数</strong></li><li>C++中cin和cout是预定义的<strong>对象</strong>，不属于C++</li><li>通过IDE编写c++源程序文件.cpp</li><li>源文件编译后变为二进制不可执行的文件.obj</li><li>.obj文件通过连接将文件变为可执行的二进制文件.exe</li><li>C语言是一种面向过程的程序设计语言，又被称为结构化程序设计</li><li>翻译程序分为3种：汇编程序，编译程序，解释程序</li></ol></li><li><p>C++基础2</p><ol><li><p>C++不允许初始化时连续赋值，但C可以</p></li><li><pre class=" language-c++"><code class="language-c++">int a=b=c=1;//会报错</code></pre></li></ol></li></ol><ol start="4"><li><p>码制</p><ol><li>八位二进制补码表示的范围：00000000为0，01111111为127，再加1到10000000为-128（<strong>负数的的补码为除符号位取反最后再加1</strong>），10000001为-127，所以八位二进制补码的范围为[-128,127]</li></ol></li><li><p>数据类型</p><ol><li>变量的数据类型定义了变量的取值范围和可以进行的操作</li><li>C++中的class，enum，struct等关键字并不代表一个自定义数据类型，他们用来定义一个自定义数据类型</li></ol></li><li><p>“0”,’\0’,”\0”,’0’的区别</p><ol><li>“0”代表一个字符串，所占内存空间大小为2，一个ascii码为48的0和一个ascii码为0的结束符组成的字符串</li><li>‘\0’代表ascii码为0的结束符</li><li>“\0”代表两个ascii码为0的结束符组成的字符串</li><li>‘0’代表一个ascii码为48的字符</li></ol></li><li><p>标识符不能包含空格和C++字符集中其他的特殊字符</p></li><li><p>基本算术运算符</p><ol><li><p>/，只要有一个操作数是浮点数，则运算结果就是浮点数</p></li><li><p>%，只能对整数运算，结果的正负由被除数决定</p></li><li><pre class=" language-c++"><code class="language-c++">(double)(26/5);//输出结果1.0</code></pre></li></ol></li><li><p>++符运算的位置</p><ol><li><pre class=" language-c++"><code class="language-c++">int x = 1;    while (x++<=8)    &#123;        if (x % 3)            continue;        cout << x;    &#125;//此处++在x和8比较完之后运行，所以x会以9进入循环//结果：369</code></pre></li><li><pre class=" language-c++"><code class="language-c++">    int a = 0;    cout<<(a++&& ++a);    cout << a;//1    cout << (a++ || a);//1//每一个结果单独运行//结果1是先判断a为0，&&不在进行后面的判断，所以只在判断完之后进行了一次++运算//结果2是左侧判断a为0，然后a自增1，到判断右侧的时候，a为1，所以判断结果为1</code></pre></li><li><p><del>所以推测后置++运算符的运算时间是跟其相连的变量进行任意一次操作后自增</del>？</p></li></ol></li><li><p><strong>运算符的优先级</strong></p></li><li><p>一元运算符</p></li><li><p>基础算术运算符</p></li><li><p>关系运算符</p></li><li><p>逻辑运算符</p></li><li><p>三目运算符？：</p></li><li><p>赋值运算符</p></li><li><p>逗号运算符</p><ol><li><pre class=" language-c++"><code class="language-c++">   //no.1   int a=1,b=2.c=3,d=4;   cout<<a+d>c+d?a+b:c<d?a+c:b+d；   //输出4   //解释：a+d为5，c+d为5，>关系运算符结果为0，即对于后面的三目运算符取c<d那一部分，c<d先进行判断，结果为true，取a+c，结果为4   //no.2   double t ;   cout<<(t=1,t+5,t++);   //输出1.0   //解释：t=1对t初始化，t+5并不赋值到t中，如果将此项作为逗号表达式最后一项，则结果为6，但是将t++作为最后一项，完成整个cout操作后t才++，所以输出结果为1，t在释放时值为2   //no.3   int a=2,b=8;   cout<<a+++b;   //被自动调整格式为a++ + b   //no.4   //如何正确表达式子1/abc   cout<<(1.0/a/b/c);</code></pre></li></ol></li></ol><ol start="18"><li><p>控制输入</p><ol><li>cin(提取运算符)以空格和回车作为分割符，不以他们作为输入信息，会忽略但不会终止输入</li><li>cin.get()一个一个字符的读取，可以设置读取到回车或者换行停止读取</li><li>cin.get(字符数组名，接受字符数目)用来接收一行字符串，可以接收空格</li><li>cin.getline()从输入流中提取字符串，，用于获取一行字符串，包含3个参数：<ol><li>字符串的起始地址</li><li>一行中最多输入的字符个数</li><li>约定行输入结束字符</li><li><strong>当第三个参数省略的时候，系统默认为’\n’</strong></li></ol></li></ol></li><li><p>进阶版—–字符数组的输入和输出，对上面的补充</p><ol><li>直接cin输入，接收键盘输入的整个字符串，遇到空格或回车结束</li><li>除了字符数组，其他类型的数组要输出数组元素的值，必须用循环语句一个元素一个元素的输出，而数组名只能代表数组的存储地址</li><li>getline(cin,string对象名称)接收一个字符串，可以接收空格并输出，需包含#include<string>，<strong>只用于string</strong></li></ol></li><li><p><strong>sizeof和strlen</strong></p><ol><li><p>sizeof()返回变量声明后所占的内存数，参数可以是数组，指针，类型，对象，函数</p></li><li><pre class=" language-c++"><code class="language-c++">char *str1="absde";char str2[]="absde";char str3[8]=&#123;'a'&#125;;char ss[] = "0123456789";​输出：​sizeof(str1)=4;//指针的大小，长整型sizeof(str2)=6;//编译时分配的数组空间的大小sizeof(str3)=8;//固定数组的大小sizeof(ss)=11//字符串的大小，字符串长度+1//函数--函数的返回类型所占的空间大小，函数的返回类型不能是void</code></pre></li></ol></li></ol><pre><code>3. strlen（char*c）计算字符串的实际长度，并不包括结束符4. str.length()和str.size()用于求string类对象的成员函数5. sizeof用于求得的字符串长度+16. 对于字符数组，strlen()和sizeof()求得结果相同</code></pre><ol start="21"><li><p>string与C++字符串数组</p><ol><li><p>包含库函数<string></p></li><li><p>string是C++标准库的一个类，定义的string变量其实是这个类的对象</p></li><li><p>将字符串常量存放到string对象中时，只存放字符串本身，不包含’\0‘</p></li><li><pre class=" language-c++"><code class="language-c++">//不必考虑string不包含'\0',对它用sizeof和strlen会怎样string str;getline(cin, str);cout << sizeof(str) << endl;cout << str.length() << endl;//对string对象用sizeof会得到固定值28//无法对string对象使用strlen，这是cstring库中直接对对字符串操作的函数//取而代之是length()和size()</code></pre></li></ol></li><li><p><strong>字符串、字符数组、字符指针</strong></p><ol><li><p>字符串</p><ol><li>系统会为字符串自动添加\0作为结束符，即使已经手动在结尾添加“abc\0”，系统仍会在后面添加’\0’<ol start="2"><li>字符数组名指代一种数据结构，这种数据结构就是数组</li><li>字符数组名是一个<strong>指针常量（即指向不能变）</strong>，其本身不可进行自增自减运算，即不能修改,但是可以<strong>借助其做地址偏移访问数组中元素</strong></li></ol></li></ol></li><li><p>初始化字符数组：</p><ol><li><p>首先分为两种方式：用双引号内的<strong>字符串常量</strong>赋值/用<strong>字符常量</strong>初始化字符数组</p></li><li><p>只能在<strong>定义</strong>的时候直接用字符串赋值</p></li><li><p>用双引号内的字符串初始化字符数组，可以省略大括号，系统自动在数组最后一个元素后补’\0’</p></li><li><p>用字符常量初始化字符数组，（字符数组长度未定）需要自己添加字符串结束符’\0’</p></li><li><p><strong>不加的话，能够成功初始化，但是不能正常输出想输出的内容</strong>，vs报乱码</p></li><li><p>在字符数组长度已知的情况下可以不用添加结束符’\0’,因为系统会把后面所有的部分都补成’\0’（如果字符串长度小于数组长度，则只将字符串中的字符赋给数组中前面的元素，剩下的内存空间系统自动用’\0’填冲</p></li><li><p>可以直接对字符数组名cin，cout</p></li><li><p><strong>在初始化之后不能对字符数组名更改或赋值，字符数组名是不可修改的左值</strong></p></li></ol></li></ol></li><li><p>字符数组的赋值：一个字符一个字符的赋值/使用strcpy(字符数组1，字符数组2)</p><ol><li>不能用赋值语句将一个字符串常量或字符数组直接给字符串赋值</li><li>字符指针<ol><li>可以开辟一个新的内存去更改或重新赋值，但不能在原地址上通过cin修改其指向的值</li><li>即指向可以改，但是不能通过解引用（或cin）改变其指向的值</li></ol></li><li>联系<ol><li><strong>两个字符数组名进行逻辑运算时，实际进行运算的是数组首地址</strong></li><li><strong>两个字符串指针进行逻辑运算时，实际进行运算的也是地址</strong></li><li><u><strong>指向相同字符串常量的指针所含的地址相等，是同一地址</strong></u></li><li>字符指针的输出<ol><li>直接输出指向某种类型的指针输出其地址值</li><li>输出指向字符串的指针时，会输出其内容</li></ol></li><li>字符数组可直接cin，cout，但是不可放在赋值号左边，即为不可修改的左值</li></ol></li></ol></li><li><p>strcpy和memcpy</p><ol><li><p>c的库函数<cstring>strcpy(字符数组1，字符串2或字符指针3或string)</p></li><li><p>其实本质上</p><pre class=" language-c++"><code class="language-c++">char*strcpy(char* dest,const char* src);</code></pre></li><li><p>strcpy只用于字符串复制，还会复制字符串的结束符,并且遇到被复制字符串的结束符’\0’才结束</p></li><li><p>memcpy提供了一般内存的复制，根据第三个参数决定复制的长度</p></li><li><p>本质上为</p><pre class=" language-c++"><code class="language-c++">void* memecpy(void* dest,const void* src,size_t count);</code></pre></li></ol></li><li><p>指针数组与数组指针</p><ol><li><pre class=" language-c++"><code class="language-c++">char *member[10]=&#123;""&#125;;//指针数组，数组元素是某种类型的指针int arr[10]=&#123;0&#125;;int(*p)[10]=&arr;//数组指针，指向数组的指针，指向数组的大小要给出</code></pre></li></ol></li><li><p>iomanip类库</p><ol><li>设置域宽，setw()，只对其后输出的第一个数据有效</li><li>endl不占用setw中设置的域宽，但是’\n’则会占用</li><li>其他操作符一旦设置，对其后的所有输入/输出都产生影响</li><li>setiosflags(ios::left)设置左对齐，默认是右对齐</li><li>setfill(char c)设置其他字符作为填冲</li><li>setprecision(int n)控制小数位数</li></ol></li><li><p><em>循环语句结构的主要部分：循环控制条件，循环体，循环控制变量</em></p></li><li><p>枚举类型</p><ol><li>第一个枚举类型成员的默认值为0，后续成员值依次加一</li><li>随意给枚举元素赋值，之后的值也是依次递加一</li></ol></li><li><p>标识符作用域</p><ol><li>以标识符起作用的范围划分：全局作用域/局部作用域（可以覆盖全局变量）</li><li>局部变量可以隐藏全局变量，如果在有同名全局变量和局部变量的情况下，可以使用域运算符::对全局变量访问</li><li><del>作用域表示符的功能是标识某个成员是属于哪个类的（包括成员函数和成员变量）（指出作用域的范围？）</del></li><li>以标识符在程序中所处的位置来划分：块作用域/函数作用域/类作用域/文件作用域</li></ol></li><li><p>内联函数</p><ol><li>内连函数体不能包含循环语句、switch语句</li><li>内联函数要先定义、后调用，不能先声明内联函数原型，再调用、定义</li><li>编译时插入</li></ol></li><li><p>递归函数</p><ol><li>递归调用指：函数中有直接调用函数自己的语句或通过其它函数间接调用函数自己的语句</li><li>递归函数的组成：更简单参数的递归调用，递归调用结束条件</li></ol></li><li><p>二维数组与指针</p><ol><li><pre class=" language-c++"><code class="language-c++">char s[3][10] = &#123; &#123;"abc"&#125;,&#123;"def"&#125;,&#123;"ghi"&#125; &#125;;    for (int i = 1; i < 3; i++)    &#123;        cout << &s[i][i];    &#125;//输出结果为efi</code></pre><p>对于二维字符数组，取地址输出，其实就跟一维字符数组里直接输出数组名，它输出整个字符串类似，所以这个直接顺着地址向后输出</p><p>注意字符数组和普通数组的输出不一样</p><p>指向一维数组的指针的间接引用结果仍然是地址，数组元素的地址</p></li><li><pre class=" language-c++"><code class="language-c++">int a[][3] = &#123; 1,2,3,4,5,6 &#125;;    int* p = &a[0][0];    int i = 1, j = 1;    cout << a[i][j] << endl;    cout << *(p + 3 * i + j) << endl;    cout << *(&a[0][0] + 3 * i + j) << endl;    cout << *(a[i] + j) << endl;    //cout << p[i][j] << endl;报错信息为：下标要求数组或指针类型//输出结果都为5//第一种是用二维数组的方式访问//第二种和第三种都是将二维数组当成一维数组的存储方式，直接按内存存储的方式加偏移量访问元素//</code></pre></li></ol></li></ol><ol start="33"><li><p>动态申请内存</p><ol><li><p>动态申请内存指针的引用</p></li><li><pre class=" language-c++"><code class="language-c++">clock& hclk=* new clock;delete& hclk;动态申请内存</code></pre></li><li><p>new</p><ol><li>对象数组<ol><li>动态申请对象数组需要使用无参构造函数，不能指定初始值</li><li>但是动态申请对象可以指定初值，也可不指定初值</li><li>对象数组既可以赋初值又可以赋值</li><li>指向对象数组的指针不一定必须指向数组的首元素，指针可以移动（p++）</li></ol></li></ol></li><li><p>delete</p><ol><li>空指针可以delete</li></ol></li></ol></li><li><p>拷贝构造函数</p><ol><li>拷贝构造函数的形参某个对象的引用名</li><li>传值的方式会调用该类的拷贝构造函数，从而造成无穷递归的调用拷贝构造函数，因此拷贝构造函数的参数必须是一个引用</li></ol></li><li><p>特殊成员函数</p><ol><li>静态成员函数<ol><li>加修饰符static</li><li>静态数据成员要在类外进行初始化</li><li>引用静态数据成员时，要在其名称前加&lt;类名&gt;和作用域运算符</li></ol></li></ol></li><li><p>C++建立类族是通过类的继承实现的</p></li><li><p>类的基础函数</p><ol><li>类的作用域是指类定义和对应的成员函数定义的范围，通俗的称为类的内部</li><li>析构函数<ol><li>前面加~只是用于区分构造函数</li><li>析构函数名和类名完全一致是错的！</li><li>析构函数是在对象被撤销时由系统自动调用，执行一些清理动作，不一定是收回分配的内存空间</li><li><strong>只负责清理新定义的成员，只清理堆区不清理栈区成员</strong>，如果没有特殊指针数据成员需要清理，可以使用由系统提供的默认析构函数</li></ol></li><li>构造函数<ol><li>一个类的构造函数必须包含对其子对象的初始化</li><li>无参构造函数包括默认构造函数和带全部默认参数值的函数</li></ol></li><li>拷贝构造函数<ol><li>当用一个对象去初始化同类的另一个对象时</li><li>如果某函数又一个参数是<strong>类a的对象</strong>，(不是类a对象的引用)那么该函数被调用时，类的拷贝构造函数被调用</li><li>如果函数的返回值是类的对象时，那么函数返回时，类的拷贝构造函数将被调用</li></ol></li></ol></li><li><p>多继承情况下的二义性</p><ol><li>解决二义性可以使用虚基类</li><li>也可以使用作用域运算符</li><li>虚函数解决类的多态性，虚基类解决二义性</li></ol></li><li><p>类与结构体</p></li><li><p>类中默认成员访问属性是private</p></li><li><p>对象成员的表示与结构变量成员表示相同，使用运算符.或-&gt;</p></li><li><p>友元函数</p><pre><code>  1. 所谓私有成员是指只有类中所提供的成员函数才能直接使用它们，任何类以外的函数对他们的访问都是非法的。（错误）私有成员还可以被友元访问</code></pre></li><li><p>指针与数组名访问数组</p><ol><li>数组名和下标 a[0],a[4]</li><li>指针和下标 pa[0],pa[4]</li><li>指针加偏移量的解引用 *(pa+1)</li><li>数组加偏移量的解引用 *(a+4)</li><li>指针自加后的间接引用，如*p++,采用这种方式会改变指针本身的值，即改变指针的指向，必要时需要对指针重新初始化</li><li>但是不允许使用数组名自加的间接引用来访问数组元素，如*a++，因为数组名是常数，所以不能通过自加改变自身</li></ol><pre class=" language-c++"><code class="language-c++">int a[] = &#123; 1,2,3,4,5 &#125;;int *p = a+1;cout << (++(*p)) << endl;cout << *(p++) << endl;cout << *p++ << endl;cout << *p << endl;/*输出结果为3334第一个是p指向a[1]，解引用为2再++为3，并且改变了a[1]的值，变为了3（注意区分自增和+1）//错误理解：第二个是p先偏移指向a[2],解引用就为a[2]的值3无论是*p++还是*(p++)都是先解引用再偏移所以第二个是p仍指向a[1],只是此时a[1]为3，再偏移指向a[2]第三个是p先解引用，为a[2]的值3，再偏移指向a[3]所以第四个直接解引用为a[3]的值4*/</code></pre></li><li><p><strong>函数的调用</strong></p><ol><li>函数语句，常用于void类型的函数</li><li>函数表达式，有返回值的函数</li><li>函数参数，函数的嵌套调用</li></ol></li><li><p>函数默认返回类型为int型，因为return默认返回1</p></li><li><p>函数重载</p><ol><li>调用原理：编译器在编译期间根据实参决定选择调用哪一个函数</li><li>作用于同一作用域</li></ol></li><li><p>函数重载与含有默认参数值的函数</p><ol><li>关系：在某些情况下可能会产生二义性，即对于被调用的一个函数，含默认参数值的函数看来是调用自己 ，在函数重载看来，是调用另一个和自身同名的函数名，只是函数参数比一样的函数</li><li>大部分情况下二者无影响</li></ol></li><li><p>同名覆盖</p><ol><li>父类中定义一个(虚)函数，在子类中重新实现了这个函数，并且函数在子类和父类中具有相同的函数原型（函数名、参数列表）</li></ol></li><li><p>函数重载与同名覆盖</p><ol><li>函数重载是同一类中的不同方法，函数覆盖是不同类中的同一方法</li><li>一般情况下，同名覆盖中多个函数的函数名，函数类型，参数等是相同的</li><li>而重载则是多个函数原型（参数）不同</li></ol></li><li><p>变量的存储类型和生存周期</p><ol><li>C++中的变量有数据类型和存储类型</li><li>auto自动变量</li><li>register寄存器变量</li><li>extern用于声明全局变量</li><li>static静态变量</li><li>不同的变量再内存中存在的时间称为变量的生存期<ol><li>不同存储类型的变量其生存期不同：静态生存期变量/动态生存期变量</li><li>动态：auto，register</li><li>静态：全局变量，静态变量</li></ol></li></ol></li><li><p>子对象</p><ol><li><p>当一个类的成员是某一个类的对象时，该对象就为子对象</p><p>自身类对象不可作为类的成员</p><p>在类中出现了子对象或对象成员（另一个类的对象）时，该类的构造函数要包含对子对象的初始化</p></li></ol></li><li><p><strong>派生类构造函数必须对这三类成员进行初始化：</strong></p><ol><li>基类成员函数</li><li>子对象构造函数</li><li>派生类构造函数</li><li>析构函数的调用顺序则恰好相反</li></ol></li><li><p>对象与类</p><ol><li>类是对象的抽象，对象是类的实例</li><li>类是一个自定义数据类型，对象是该数据类型的一个变量</li></ol></li><li><p>继承</p><ol><li>定义新类是通过继承机制实现的</li><li>派生类继承了基类的所有成员，但不包括构造函数，析构函数和默认赋值运算符</li><li>派生类的构造函数要初始化本类的数据成员，还要调用基类的构造函数，并为基类构造函数传递参数</li><li>派生类构造函数的成员初始化列表中，包含：基类的构造函数，派生类中子对象的初始化，派生类中一般数据成员的初始化，不能包含基类中子对象（基类的数据成员）的初始化（这个东西的初始化是通过基类的构造函数）</li><li>对基类数据成员的初始化必须在派生类的初始化列表中执行</li><li>子对象的构造函数调用的顺序是按照类的定义的顺序来的</li></ol></li><li><p>继承方式和访问控制</p><ol><li><p>单独一个类的访问控制权限</p><ol><li>public成员允许被类外的函数访问</li><li>protected成员允许被本类的成员函数或者派生类的成员函数访问</li><li>private成员只能被本类的成员函数访问</li></ol></li><li><p>访问控制</p><ol><li>protected        <ol><li>protected成员不能被本类对象直接访问    </li><li>protected成员不能通过派生类对象直接访问</li><li>protected成员可以被本类成员函数和派生类成员函数访问</li></ol></li><li>public继承的public成员<ol><li>可以派生类对象直接访问</li></ol></li></ol></li><li><p>继承方式</p><ol><li>对于派生类成员函数，无论什么继承方式，其都可以访问基类的public和protected</li><li>public继承，派生类对象只能访问基类public成员</li></ol></li></ol></li><li><p>类与继承编程</p><ol><li><p>可以将字符指针直接赋值给string字符串，需要使用strcpy()才可将字符指针赋给字符数组<cstring>库中</p></li><li><p>对象数组初始化的方法：</p><ol><li>类名 数组名[]={构造函数调用， ， }；</li></ol></li><li><p>调用外部函数时，需要将实参值复制给形参，如果类的数据成员较多，可以使用对象指针或对象引用传递函数参数</p></li><li><p>动态创建一个对象并初始化</p><pre class=" language-c++"><code class="language-c++">clock c1;//clock为类名c1=new clock (形式参数表);</code></pre></li><li><p>经典代码语句：</p><pre class=" language-c++"><code class="language-c++">name=new char [strlen(c)+1];strcpy(name,c);</code></pre></li></ol></li></ol><ol start="57"><li><p>析构与拷贝</p><ol><li>拷贝构造函数的形参一定是对象的引用</li><li>如果外在函数本身带有引用，则不调用类中的拷贝构造函数，并且对于引用不再次析构</li><li>如果外在函数直接传值得话，系统会调用拷贝构造函数，但是会创建对象的副本，这个副本会调用析构函数</li></ol><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;class clock &#123;public:    clock()    &#123;        cout << "构造" << endl;    &#125;    clock(clock& c)    &#123;        cout << "拷贝1" << endl;    &#125;    /*clock(clock c)    &#123;        cout << "拷贝2";    &#125;*/    ~clock()    &#123;        cout << "析构" << endl;    &#125;&#125;;void newclock1(clock c1)&#123;    cout << "函数1" << endl;&#125;void newclock2(clock& c2)&#123;    cout << "函数2" << endl;&#125;int main()&#123;    clock c;    newclock1(c);    newclock2(c);&#125;//输出结果为：构造拷贝1函数1析构函数2析构</code></pre></li><li><p>出现指针的形参能加const就加const</p></li><li><p>指向类数据成员的指针</p><ol><li><p>通过对象来引用指针所指向的成员</p></li><li><p>&lt;类对象名&gt;.*&lt;指向非静态数据成员的指针&gt;</p></li><li><p>&lt;类对象指针&gt;-&gt;*&lt;指向非静态数据成员的指针&gt;</p></li><li><pre class=" language-c++"><code class="language-c++">student s("zhang",100);cout<<s.*ps<<endl;student *pp=new student("wu",99);cout<<pp->*ps<<endl;</code></pre></li></ol></li><li><p>struct的字节对齐问题</p><ol><li><pre class=" language-c++"><code class="language-c++">struct student &#123;    int id;    char name[16];    double score;&#125;;student s1;cout << sizeof(student);cout << &s1.id << endl;cout << &s1.name << endl;cout << &s1.score << endl;/*输出结果为：32003BFA4C003BFA50003BFA64int占了4个字节，然后char占了16个字节，最后double寻址的时候发现16-24被占用了，所以占用了第24-32字节，所以总共占用了32个字节*/</code></pre></li><li><p>double和int这一类的分配内存只针对它自己的字节，char比较特殊，如果结构体中只有单独的char，是补不齐的，char是多长结构体就是多少个字节，但是char和其他类型的都在结构体中就会出现常规意义上的补齐</p></li><li><p>结构体中有double，那么double附近的东西会被补成8个字节空间，最后字节长度会是8的倍数</p></li><li><p>关于short和char，char会被补到2的倍数</p></li></ol></li></ol><p>易错：</p><ol><li><p>手写调用函数时，记得加括号</p></li><li><pre class=" language-c++"><code class="language-c++">//a[i][j]实际上是第i+1行，第j+1列</code></pre></li><li><p>联合和枚举类型定义后要加分号;</p></li></ol><p>借鉴：</p><ol><li>指针指向的不是一个值，而是一个变量，比如++(*p),不仅输出的值加一，p指向的变量也加一</li><li>引用是对变量的直接访问，指针是对变量的间接访问</li><li>在动态申请数组空间时，不可以对数组进行初始化</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-复习&quot;&gt;&lt;a href=&quot;#C-复习&quot; class=&quot;headerlink&quot; title=&quot;C++复习&quot;&gt;&lt;/a&gt;C++复习&lt;/h2&gt;&lt;p&gt;北京邮电大学期末复习考试资料&lt;/p&gt;
&lt;p&gt;适用于北京邮电大学《C++程序设计语言》期末考试&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;</summary>
      
    
    
    
    
    <category term="C++" scheme="https://1doctorc1.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://1doctorc1.github.io/2021/01/11/hello-world/"/>
    <id>https://1doctorc1.github.io/2021/01/11/hello-world/</id>
    <published>2021-01-11T02:18:56.158Z</published>
    <updated>2021-01-11T03:35:11.558Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="hello-hexo"><a href="#hello-hexo" class="headerlink" title="hello hexo"></a>hello hexo</h2><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
