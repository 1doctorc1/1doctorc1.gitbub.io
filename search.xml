<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++期末复习</title>
      <link href="2021/01/31/c-qi-mo-fu-xi/"/>
      <url>2021/01/31/c-qi-mo-fu-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="C-复习"><a href="#C-复习" class="headerlink" title="C++复习"></a>C++复习</h2><ol><li><p>C基础</p><ol><li>面向过程的程序设计语言/结构化程序设计</li><li>结构化数据，结构化语句，数据抽象，过程抽象</li><li>面向<em>过程</em>的程序设计主要思想是<em>自顶向下</em>，逐步求精，模块化</li></ol></li><li><p>C++基础</p><ol><li>自底向上的分析，是从具体到抽象，因为oop(面向对象编程)的第一步是从对象抽象出类</li><li>自顶向下的分析，是从抽象到具体，从大概要处理数据的什么功能细致的规划每一个步骤</li><li>组成C++程序的是<strong>函数</strong></li><li>C++中cin和cout是预定义的<strong>对象</strong>，不属于C++</li><li>通过IDE编写c++源程序文件.cpp</li><li>源文件编译后变为二进制不可执行的文件.obj</li><li>.obj文件通过连接将文件变为可执行的二进制文件.exe</li><li>C语言是一种面向过程的程序设计语言，又被称为结构化程序设计</li><li>翻译程序分为3种：汇编程序，编译程序，解释程序</li></ol></li><li><p>C++基础2</p><ol><li><p>C++不允许初始化时连续赋值，但C可以</p></li><li><pre class=" language-c++"><code class="language-c++">int a=b=c=1;//会报错</code></pre></li></ol></li></ol><ol start="4"><li><p>码制</p><ol><li>八位二进制补码表示的范围：00000000为0，01111111为127，再加1到10000000为-128（<strong>负数的的补码为除符号位取反最后再加1</strong>），10000001为-127，所以八位二进制补码的范围为[-128,127]</li></ol></li><li><p>数据类型</p><ol><li>变量的数据类型定义了变量的取值范围和可以进行的操作</li><li>C++中的class，enum，struct等关键字并不代表一个自定义数据类型，他们用来定义一个自定义数据类型</li></ol></li><li><p>“0”,’\0’,”\0”,’0’的区别</p><ol><li>“0”代表一个字符串，所占内存空间大小为2，一个ascii码为48的0和一个ascii码为0的结束符组成的字符串</li><li>‘\0’代表ascii码为0的结束符</li><li>“\0”代表两个ascii码为0的结束符组成的字符串</li><li>‘0’代表一个ascii码为48的字符</li></ol></li><li><p>标识符不能包含空格和C++字符集中其他的特殊字符</p></li><li><p>基本算术运算符</p><ol><li><p>/，只要有一个操作数是浮点数，则运算结果就是浮点数</p></li><li><p>%，只能对整数运算，结果的正负由被除数决定</p></li><li><pre class=" language-c++"><code class="language-c++">(double)(26/5);//输出结果1.0</code></pre></li></ol></li><li><p>++符运算的位置</p><ol><li><pre class=" language-c++"><code class="language-c++">int x = 1;    while (x++<=8)    &#123;        if (x % 3)            continue;        cout << x;    &#125;//此处++在x和8比较完之后运行，所以x会以9进入循环//结果：369</code></pre></li><li><pre class=" language-c++"><code class="language-c++">    int a = 0;    cout<<(a++&& ++a);    cout << a;//1    cout << (a++ || a);//1//每一个结果单独运行//结果1是先判断a为0，&&不在进行后面的判断，所以只在判断完之后进行了一次++运算//结果2是左侧判断a为0，然后a自增1，到判断右侧的时候，a为1，所以判断结果为1</code></pre></li><li><p><del>所以推测后置++运算符的运算时间是跟其相连的变量进行任意一次操作后自增</del>？</p></li></ol></li><li><p><strong>运算符的优先级</strong></p></li><li><p>一元运算符</p></li><li><p>基础算术运算符</p></li><li><p>关系运算符</p></li><li><p>逻辑运算符</p></li><li><p>三目运算符？：</p></li><li><p>赋值运算符</p></li><li><p>逗号运算符</p><pre class=" language-c++"><code class="language-c++">//no.1int a=1,b=2.c=3,d=4;cout<<a+d>c+d?a+b:c<d?a+c:b+d；//输出4//解释：a+d为5，c+d为5，>关系运算符结果为0，即对于后面的三目运算符取c<d那一部分，c<d先进行判断，结果为true，取a+c，结果为4//no.2double t ;cout<<(t=1,t+5,t++);//输出1.0//解释：t=1对t初始化，t+5并不赋值到t中，如果将此项作为逗号表达式最后一项，则结果为6，但是将t++作为最后一项，完成整个cout操作后t才++，所以输出结果为1，t在释放时值为2//no.3int a=2,b=8;cout<<a+++b;//被自动调整格式为a++ + b//no.4//如何正确表达式子1/abccout<<(1.0/a/b/c);</code></pre></li></ol><ol start="11"><li><p>控制输入</p><ol><li>cin(提取运算符)以空格和回车作为分割符，不以他们作为输入信息，会忽略但不会终止输入</li><li>cin.get()一个一个字符的读取，可以设置读取到回车或者换行停止读取</li><li>cin.get(字符数组名，接受字符数目)用来接收一行字符串，可以接收空格</li><li>cin.getline()从输入流中提取字符串，，用于获取一行字符串，包含3个参数：<ol><li>字符串的起始地址</li><li>一行中最多输入的字符个数</li><li>约定行输入结束字符</li><li><strong>当第三个参数省略的时候，系统默认为’\n’</strong></li></ol></li></ol></li><li><p>进阶版—–字符数组的输入和输出，对上面的补充</p><ol><li>直接cin输入，接收键盘输入的整个字符串，遇到空格或回车结束</li><li>除了字符数组，其他类型的数组要输出数组元素的值，必须用循环语句一个元素一个元素的输出，而数组名只能代表数组的存储地址</li><li>getline(cin,string对象名称)接收一个字符串，可以接收空格并输出，需包含#include<string>，<strong>只用于string</strong></li></ol></li><li><p><strong>sizeof和strlen</strong></p><ol><li><p>sizeof()返回变量声明后所占的内存数，参数可以是数组，指针，类型，对象，函数</p></li><li><pre class=" language-c++"><code class="language-c++">char *str1="absde";char str2[]="absde";char str3[8]=&#123;'a'&#125;;char ss[] = "0123456789";​输出：​sizeof(str1)=4;//指针的大小，长整型sizeof(str2)=6;//编译时分配的数组空间的大小sizeof(str3)=8;//固定数组的大小sizeof(ss)=11//字符串的大小，字符串长度+1//函数--函数的返回类型所占的空间大小，函数的返回类型不能是void</code></pre></li></ol></li></ol><pre><code>3. strlen（char*c）计算字符串的实际长度，并不包括结束符4. str.length()和str.size()用于求string类对象的成员函数5. sizeof用于求得的字符串长度+16. 对于字符数组，strlen()和sizeof()求得结果相同</code></pre><ol start="14"><li><p>string与C++字符串数组</p><ol><li><p>包含库函数<string></p></li><li><p>string是C++标准库的一个类，定义的string变量其实是这个类的对象</p></li><li><p>将字符串常量存放到string对象中时，只存放字符串本身，不包含’\0‘</p></li><li><pre class=" language-c++"><code class="language-c++">//不必考虑string不包含'\0',对它用sizeof和strlen会怎样string str;getline(cin, str);cout << sizeof(str) << endl;cout << str.length() << endl;//对string对象用sizeof会得到固定值28//无法对string对象使用strlen，这是cstring库中直接对对字符串操作的函数//取而代之是length()和size()</code></pre></li></ol></li><li><p><strong>字符串、字符数组、字符指针</strong></p><ol><li><p>字符串</p><ol><li>系统会为字符串自动添加\0作为结束符，即使已经手动在结尾添加“abc\0”，系统仍会在后面添加’\0’<ol start="2"><li>字符数组名指代一种数据结构，这种数据结构就是数组</li><li>字符数组名是一个<strong>指针常量（即指向不能变）</strong>，其本身不可进行自增自减运算，即不能修改,但是可以<strong>借助其做地址偏移访问数组中元素</strong></li></ol></li></ol></li><li><p>初始化字符数组：</p><ol><li><p>首先分为两种方式：用双引号内的<strong>字符串常量</strong>赋值/用<strong>字符常量</strong>初始化字符数组</p></li><li><p>只能在<strong>定义</strong>的时候直接用字符串赋值</p></li><li><p>用双引号内的字符串初始化字符数组，可以省略大括号，系统自动在数组最后一个元素后补’\0’</p></li><li><p>用字符常量初始化字符数组，（字符数组长度未定）需要自己添加字符串结束符’\0’</p></li><li><p><strong>不加的话，能够成功初始化，但是不能正常输出想输出的内容</strong>，vs报乱码</p></li><li><p>在字符数组长度已知的情况下可以不用添加结束符’\0’,因为系统会把后面所有的部分都补成’\0’（如果字符串长度小于数组长度，则只将字符串中的字符赋给数组中前面的元素，剩下的内存空间系统自动用’\0’填冲</p></li><li><p>可以直接对字符数组名cin，cout</p></li><li><p><strong>在初始化之后不能对字符数组名更改或赋值，字符数组名是不可修改的左值</strong></p></li></ol></li></ol></li><li><p>字符数组的赋值：一个字符一个字符的赋值/使用strcpy(字符数组1，字符数组2)</p><ol><li>不能用赋值语句将一个字符串常量或字符数组直接给字符串赋值</li><li>字符指针<ol><li>可以开辟一个新的内存去更改或重新赋值，但不能在原地址上通过cin修改其指向的值</li><li>即指向可以改，但是不能通过解引用（或cin）改变其指向的值</li></ol></li><li>联系<ol><li><strong>两个字符数组名进行逻辑运算时，实际进行运算的是数组首地址</strong></li><li><strong>两个字符串指针进行逻辑运算时，实际进行运算的也是地址</strong></li><li><u><strong>指向相同字符串常量的指针所含的地址相等，是同一地址</strong></u></li><li>字符指针的输出<ol><li>直接输出指向某种类型的指针输出其地址值</li><li>输出指向字符串的指针时，会输出其内容</li></ol></li><li>字符数组可直接cin，cout，但是不可放在赋值号左边，即为不可修改的左值</li></ol></li></ol></li><li><p>strcpy和memcpy</p><ol><li><p>c的库函数<cstring>strcpy(字符数组1，字符串2或字符指针3或string)</p></li><li><p>其实本质上</p><pre class=" language-c++"><code class="language-c++">char*strcpy(char* dest,const char* src);</code></pre></li><li><p>strcpy只用于字符串复制，还会复制字符串的结束符,并且遇到被复制字符串的结束符’\0’才结束</p></li><li><p>memcpy提供了一般内存的复制，根据第三个参数决定复制的长度</p></li><li><p>本质上为</p><pre class=" language-c++"><code class="language-c++">void* memecpy(void* dest,const void* src,size_t count);</code></pre></li></ol></li><li><p>指针数组与数组指针</p><ol><li><pre class=" language-c++"><code class="language-c++">char *member[10]=&#123;""&#125;;//指针数组，数组元素是某种类型的指针int arr[10]=&#123;0&#125;;int(*p)[10]=&arr;//数组指针，指向数组的指针，指向数组的大小要给出</code></pre></li></ol></li><li><p>iomanip类库</p><ol><li>设置域宽，setw()，只对其后输出的第一个数据有效</li><li>endl不占用setw中设置的域宽，但是’\n’则会占用</li><li>其他操作符一旦设置，对其后的所有输入/输出都产生影响</li><li>setiosflags(ios::left)设置左对齐，默认是右对齐</li><li>setfill(char c)设置其他字符作为填冲</li><li>setprecision(int n)控制小数位数</li></ol></li><li><p><em>循环语句结构的主要部分：循环控制条件，循环体，循环控制变量</em></p></li><li><p>枚举类型</p><ol><li>第一个枚举类型成员的默认值为0，后续成员值依次加一</li><li>随意给枚举元素赋值，之后的值也是依次递加一</li></ol></li><li><p>标识符作用域</p><ol><li>以标识符起作用的范围划分：全局作用域/局部作用域（可以覆盖全局变量）</li><li>局部变量可以隐藏全局变量，如果在有同名全局变量和局部变量的情况下，可以使用域运算符::对全局变量访问</li><li><del>作用域表示符的功能是标识某个成员是属于哪个类的（包括成员函数和成员变量）（指出作用域的范围？）</del></li><li>以标识符在程序中所处的位置来划分：块作用域/函数作用域/类作用域/文件作用域</li></ol></li></ol><ol><li><p>内联函数</p><ol><li>内连函数体不能包含循环语句、switch语句</li><li>内联函数要先定义、后调用，不能先声明内联函数原型，再调用、定义</li><li>编译时插入</li></ol></li><li><p>递归函数</p><ol><li>递归调用指：函数中有直接调用函数自己的语句或通过其它函数间接调用函数自己的语句</li><li>递归函数的组成：更简单参数的递归调用，递归调用结束条件</li></ol></li><li><p>二维数组与指针</p><ol><li><pre class=" language-c++"><code class="language-c++">char s[3][10] = &#123; &#123;"abc"&#125;,&#123;"def"&#125;,&#123;"ghi"&#125; &#125;;    for (int i = 1; i < 3; i++)    &#123;        cout << &s[i][i];    &#125;//输出结果为efi</code></pre><p>对于二维字符数组，取地址输出，其实就跟一维字符数组里直接输出数组名，它输出整个字符串类似，所以这个直接顺着地址向后输出</p><p>注意字符数组和普通数组的输出不一样</p><p>指向一维数组的指针的间接引用结果仍然是地址，数组元素的地址</p></li><li><pre class=" language-c++"><code class="language-c++">int a[][3] = &#123; 1,2,3,4,5,6 &#125;;    int* p = &a[0][0];    int i = 1, j = 1;    cout << a[i][j] << endl;    cout << *(p + 3 * i + j) << endl;    cout << *(&a[0][0] + 3 * i + j) << endl;    cout << *(a[i] + j) << endl;    //cout << p[i][j] << endl;报错信息为：下标要求数组或指针类型//输出结果都为5//第一种是用二维数组的方式访问//第二种和第三种都是将二维数组当成一维数组的存储方式，直接按内存存储的方式加偏移量访问元素//</code></pre></li></ol></li></ol><ol start="4"><li><p>动态申请内存</p><ol><li><p>动态申请内存指针的引用</p></li><li><pre class=" language-c++"><code class="language-c++">clock& hclk=* new clock;delete& hclk;动态申请内存</code></pre></li><li><p>new</p><ol><li>对象数组<ol><li>动态申请对象数组需要使用无参构造函数，不能指定初始值</li><li>但是动态申请对象可以指定初值，也可不指定初值</li><li>对象数组既可以赋初值又可以赋值</li><li>指向对象数组的指针不一定必须指向数组的首元素，指针可以移动（p++）</li></ol></li></ol></li><li><p>delete</p><ol><li>空指针可以delete</li></ol></li></ol></li><li><p>拷贝构造函数</p><ol><li>拷贝构造函数的形参某个对象的引用名</li><li>传值的方式会调用该类的拷贝构造函数，从而造成无穷递归的调用拷贝构造函数，因此拷贝构造函数的参数必须是一个引用</li></ol></li><li><p>特殊成员函数</p><ol><li>静态成员函数<ol><li>加修饰符static</li><li>静态数据成员要在类外进行初始化</li><li>引用静态数据成员时，要在其名称前加&lt;类名&gt;和作用域运算符</li></ol></li></ol></li><li><p>C++建立类族是通过类的继承实现的</p></li><li><p>类的基础函数</p><ol><li>类的作用域是指类定义和对应的成员函数定义的范围，通俗的称为类的内部</li><li>析构函数<ol><li>前面加~只是用于区分构造函数</li><li>析构函数名和类名完全一致是错的！</li><li>析构函数是在对象被撤销时由系统自动调用，执行一些清理动作，不一定是收回分配的内存空间</li><li><strong>只负责清理新定义的成员，只清理堆区不清理栈区成员</strong>，如果没有特殊指针数据成员需要清理，可以使用由系统提供的默认析构函数</li></ol></li><li>构造函数<ol><li>一个类的构造函数必须包含对其子对象的初始化</li><li>无参构造函数包括默认构造函数和带全部默认参数值的函数</li></ol></li><li>拷贝构造函数<ol><li>当用一个对象去初始化同类的另一个对象时</li><li>如果某函数又一个参数是<strong>类a的对象</strong>，(不是类a对象的引用)那么该函数被调用时，类的拷贝构造函数被调用</li><li>如果函数的返回值是类的对象时，那么函数返回时，类的拷贝构造函数将被调用</li></ol></li></ol></li><li><p>多继承情况下的二义性</p><ol><li>解决二义性可以使用虚基类</li><li>也可以使用作用域运算符</li><li>虚函数解决类的多态性，虚基类解决二义性</li></ol></li><li><p>类与结构体</p></li><li><p>类中默认成员访问属性是private</p></li><li><p>对象成员的表示与结构变量成员表示相同，使用运算符.或-&gt;</p></li><li><p>友元函数</p><pre><code>  1. 所谓私有成员是指只有类中所提供的成员函数才能直接使用它们，任何类以外的函数对他们的访问都是非法的。（错误）私有成员还可以被友元访问</code></pre></li><li><p>指针与数组名访问数组</p><ol><li>数组名和下标 a[0],a[4]</li><li>指针和下标 pa[0],pa[4]</li><li>指针加偏移量的解引用 *(pa+1)</li><li>数组加偏移量的解引用 *(a+4)</li><li>指针自加后的间接引用，如*p++,采用这种方式会改变指针本身的值，即改变指针的指向，必要时需要对指针重新初始化</li><li>但是不允许使用数组名自加的间接引用来访问数组元素，如*a++，因为数组名是常数，所以不能通过自加改变自身</li></ol><pre class=" language-c++"><code class="language-c++">int a[] = &#123; 1,2,3,4,5 &#125;;int *p = a+1;cout << (++(*p)) << endl;cout << *(p++) << endl;cout << *p++ << endl;cout << *p << endl;/*输出结果为3334第一个是p指向a[1]，解引用为2再++为3，并且改变了a[1]的值，变为了3（注意区分自增和+1）//错误理解：第二个是p先偏移指向a[2],解引用就为a[2]的值3无论是*p++还是*(p++)都是先解引用再偏移所以第二个是p仍指向a[1],只是此时a[1]为3，再偏移指向a[2]第三个是p先解引用，为a[2]的值3，再偏移指向a[3]所以第四个直接解引用为a[3]的值4*/</code></pre></li><li><p><strong>函数的调用</strong></p><ol><li>函数语句，常用于void类型的函数</li><li>函数表达式，有返回值的函数</li><li>函数参数，函数的嵌套调用</li></ol></li><li><p>函数默认返回类型为int型，因为return默认返回1</p></li><li><p>函数重载</p><ol><li>调用原理：编译器在编译期间根据实参决定选择调用哪一个函数</li><li>作用于同一作用域</li></ol></li><li><p>函数重载与含有默认参数值的函数</p><ol><li>关系：在某些情况下可能会产生二义性，即对于被调用的一个函数，含默认参数值的函数看来是调用自己 ，在函数重载看来，是调用另一个和自身同名的函数名，只是函数参数比一样的函数</li><li>大部分情况下二者无影响</li></ol></li><li><p>同名覆盖</p><ol><li>父类中定义一个(虚)函数，在子类中重新实现了这个函数，并且函数在子类和父类中具有相同的函数原型（函数名、参数列表）</li></ol></li><li><p>函数重载与同名覆盖</p><ol><li>函数重载是同一类中的不同方法，函数覆盖是不同类中的同一方法</li><li>一般情况下，同名覆盖中多个函数的函数名，函数类型，参数等是相同的</li><li>而重载则是多个函数原型（参数）不同</li></ol></li><li><p>变量的存储类型和生存周期</p><ol><li>C++中的变量有数据类型和存储类型</li><li>auto自动变量</li><li>register寄存器变量</li><li>extern用于声明全局变量</li><li>static静态变量</li><li>不同的变量再内存中存在的时间称为变量的生存期<ol><li>不同存储类型的变量其生存期不同：静态生存期变量/动态生存期变量</li><li>动态：auto，register</li><li>静态：全局变量，静态变量</li></ol></li></ol></li><li><p>子对象</p><ol><li><p>当一个类的成员是某一个类的对象时，该对象就为子对象</p><p>自身类对象不可作为类的成员</p><p>在类中出现了子对象或对象成员（另一个类的对象）时，该类的构造函数要包含对子对象的初始化</p></li></ol></li><li><p><strong>派生类构造函数必须对这三类成员进行初始化：</strong></p><ol><li>基类成员函数</li><li>子对象构造函数</li><li>派生类构造函数</li><li>析构函数的调用顺序则恰好相反</li></ol></li><li><p>对象与类</p><ol><li>类是对象的抽象，对象是类的实例</li><li>类是一个自定义数据类型，对象是该数据类型的一个变量</li></ol></li><li><p>继承</p><ol><li>定义新类是通过继承机制实现的</li><li>派生类继承了基类的所有成员，但不包括构造函数，析构函数和默认赋值运算符</li><li>派生类的构造函数要初始化本类的数据成员，还要调用基类的构造函数，并为基类构造函数传递参数</li><li>派生类构造函数的成员初始化列表中，包含：基类的构造函数，派生类中子对象的初始化，派生类中一般数据成员的初始化，不能包含基类中子对象（基类的数据成员）的初始化（这个东西的初始化是通过基类的构造函数）</li><li>对基类数据成员的初始化必须在派生类的初始化列表中执行</li><li>子对象的构造函数调用的顺序是按照类的定义的顺序来的</li></ol></li><li><p>继承方式和访问控制</p><ol><li><p>单独一个类的访问控制权限</p><ol><li>public成员允许被类外的函数访问</li><li>protected成员允许被本类的成员函数或者派生类的成员函数访问</li><li>private成员只能被本类的成员函数访问</li></ol></li><li><p>访问控制</p><ol><li>protected        <ol><li>protected成员不能被本类对象直接访问    </li><li>protected成员不能通过派生类对象直接访问</li><li>protected成员可以被本类成员函数和派生类成员函数访问</li></ol></li><li>public继承的public成员<ol><li>可以派生类对象直接访问</li></ol></li></ol></li><li><p>继承方式</p><ol><li>对于派生类成员函数，无论什么继承方式，其都可以访问基类的public和protected</li><li>public继承，派生类对象只能访问基类public成员</li></ol></li></ol></li><li><p>类与继承编程</p><ol><li><p>可以将字符指针直接赋值给string字符串，需要使用strcpy()才可将字符指针赋给字符数组<cstring>库中</p></li><li><p>对象数组初始化的方法：</p><ol><li>类名 数组名[]={构造函数调用， ， }；</li></ol></li><li><p>调用外部函数时，需要将实参值复制给形参，如果类的数据成员较多，可以使用对象指针或对象引用传递函数参数</p></li><li><p>动态创建一个对象并初始化</p><pre class=" language-c++"><code class="language-c++">clock c1;//clock为类名c1=new clock (形式参数表);</code></pre></li><li><p>经典代码语句：</p><pre class=" language-c++"><code class="language-c++">name=new char [strlen(c)+1];strcpy(name,c);</code></pre></li></ol></li></ol><ol start="28"><li><p>析构与拷贝</p><ol><li>拷贝构造函数的形参一定是对象的引用</li><li>如果外在函数本身带有引用，则不调用类中的拷贝构造函数，并且对于引用不再次析构</li><li>如果外在函数直接传值得话，系统会调用拷贝构造函数，但是会创建对象的副本，这个副本会调用析构函数</li></ol><pre class=" language-c++"><code class="language-c++">#include<iostream>using namespace std;class clock &#123;public:    clock()    &#123;        cout << "构造" << endl;    &#125;    clock(clock& c)    &#123;        cout << "拷贝1" << endl;    &#125;    /*clock(clock c)    &#123;        cout << "拷贝2";    &#125;*/    ~clock()    &#123;        cout << "析构" << endl;    &#125;&#125;;void newclock1(clock c1)&#123;    cout << "函数1" << endl;&#125;void newclock2(clock& c2)&#123;    cout << "函数2" << endl;&#125;int main()&#123;    clock c;    newclock1(c);    newclock2(c);&#125;//输出结果为：构造拷贝1函数1析构函数2析构</code></pre></li><li><p>出现指针的形参能加const就加const</p></li><li><p>指向类数据成员的指针</p><ol><li><p>通过对象来引用指针所指向的成员</p></li><li><p>&lt;类对象名&gt;.*&lt;指向非静态数据成员的指针&gt;</p></li><li><p>&lt;类对象指针&gt;-&gt;*&lt;指向非静态数据成员的指针&gt;</p></li><li><pre class=" language-c++"><code class="language-c++">student s("zhang",100);cout<<s.*ps<<endl;student *pp=new student("wu",99);cout<<pp->*ps<<endl;</code></pre></li></ol></li><li><p>struct的字节对齐问题</p><ol><li><pre class=" language-c++"><code class="language-c++">struct student &#123;    int id;    char name[16];    double score;&#125;;student s1;cout << sizeof(student);cout << &s1.id << endl;cout << &s1.name << endl;cout << &s1.score << endl;/*输出结果为：32003BFA4C003BFA50003BFA64int占了4个字节，然后char占了16个字节，最后double寻址的时候发现16-24被占用了，所以占用了第24-32字节，所以总共占用了32个字节*/</code></pre></li><li><p>double和int这一类的分配内存只针对它自己的字节，char比较特殊，如果结构体中只有单独的char，是补不齐的，char是多长结构体就是多少个字节，但是char和其他类型的都在结构体中就会出现常规意义上的补齐</p></li><li><p>结构体中有double，那么double附近的东西会被补成8个字节空间，最后字节长度会是8的倍数</p></li><li><p>关于short和char，char会被补到2的倍数</p></li></ol></li></ol><p>易错：</p><ol><li><p>手写调用函数时，记得加括号</p></li><li><pre class=" language-c++"><code class="language-c++">//a[i][j]实际上是第i+1行，第j+1列</code></pre></li><li><p>联合和枚举类型定义后要加分号;</p></li></ol><p>借鉴：</p><ol><li>指针指向的不是一个值，而是一个变量，比如++(*p),不仅输出的值加一，p指向的变量也加一</li><li>引用是对变量的直接访问，指针是对变量的间接访问</li><li>在动态申请数组空间时，不可以对数组进行初始化</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/01/11/hello-world/"/>
      <url>2021/01/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="hello-hexo"><a href="#hello-hexo" class="headerlink" title="hello hexo"></a>hello hexo</h2><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
